## 13. 3 락 최적화

---

### 스핀 락과 적응형 스핀

1. 스핀락
    - 스레드가 락을 얻기 위해 계속해서 락 상태를 확인해가며 반복적으로 시도하는 방법
    - 멀티 코어 시스템에서는 대기 없이 사용 가능
    - 스레드 전환 부하는 줄였지만, 프로세서 시간을 소비
2. 적응형 스핀
    - 락을 기다리는 스레드가 락의 상태와 시스템 상황을 기반으로 스핀을 계속 할지, 블락을 할지 결정
    - 하나의 락 객체의 성공 여부에 따라 다음번의 성공 가능성 판단

### 락 제거

- JVM이 불필요한 락을 제거하여 성능 최적화
- 앞선 챕터에서 언급했듯이 코드가 락을 사용하는 것이 불필요하다고 판단 시 사용 → 오버헤드를 줄일 수 있다.
- 동작 방식
    - JVM이 코드가 특정 스레드 내에서 동작하는 지, 다른 스레드가 접근 가능한지 판단

### 락 범위 확장

- JVM이 동일한 락 객체를 잠그는 과정이 반복되는 것을 탐지한다면 락의 유효범위를 해당 작업 전체로 늘린다.

### 경량 락

- 경쟁이 없을 때 락을 빠르게 획득 → 경쟁 발생 시 중량락 (일반락)
- 오버헤드를 줄일 수 있다. 단, 경략 락에서 중량락으로 전환 시 일반 락 사용시 보다 비용이 클 수 있다.
- 따라서 경합이 발생하지 않는 환경에서 적합

### 편향 락

- 락이 특정 스레드에 편향되어 있다고 가정 → 마지막으로 사용한 스레드가 찜
- 다른 스레드가 가져가지 않으면 불필요한 락획득 해제를 줄일 수 있다. (CAS조차 사용하지 않음)→ 오버헤드를 줄일 수 있다.
- 마찬가지로 경합이 발생하지 않는 환경에서 적합

### 결론

JVM은 프로그램 실행 중 **동적 분석**을 통해 가장 적합한 락 최적화 기법을 선택

https://blogs.oracle.com/javamagazine/post/escape-analysis-in-the-hotspot-jit-compiler?utm_source=chatgpt.com

https://docs.oracle.com/cd/E13150_01/jrockit_jvm/jrockit/geninfo/diagnos/locktuning.html?utm_source=chatgpt.com