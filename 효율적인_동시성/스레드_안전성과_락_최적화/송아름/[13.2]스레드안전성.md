## 스레드 안전성

<br>

> 자바의 공유데이터 안전성 목차<br>
> - 불변 <br>
> - 절대적 스레드 안전<br>
> - 조건부 스레드 안전<br>
> - 스레드 호환<br>
> - 스레드 적대적<br>

<br>

####  스레드 안정성과 불변성 ( 최초 초기화 이후 변경불가 => 동기화 불필요 )

<br>


1. 불변객체 (Immutable Object) : 상태 변경이 불가능한 객체
   ###### 장점 : 스레드 안전성 / 캐싱
   ######  단점 : 메모리 소비 
######  📝 불변객체 만들기 final class! final field!
```JAVA
public final class Person {
    private final String name;
    private final List<String> hobbies;

    public Person(String name, List<String> hobbies) {
        this.name = name;
        // 방어적 복사 => 참조를 저장하지 않도록
        this.hobbies = new ArrayList<>(hobbies);
    }

    //getter 메소드만
    public String getName() {
        return name;
    }

    public List<String> getHobbies() {
        // 방어적 복사하여 외부에서 리스트를 변경할 수 없게 함
        return new ArrayList<>(hobbies);
    }
}
```
 
   
<br>

2. final
   ###### ::: final class ::: 상속 방지 (메소드를 오버라이드하거나 필드 값을 변경할 수 없도록)
   ###### ::: final 기본자료형 :::
   ###### ::: final 참조 변수 :::
   ######  📌 final 참조 변수 주의할 점
```JAVA
public class Example {
    public static void main(String[] args) {
       
        final Person person = new Person("Alice", 25);
        
        // 참조 자체는 변경 불가능
        // person = new Person("Bob", 30);  
        
        // 참조된 객체의 내부 상태는 변경 가능
        person.setAge(30);

    }
}

class Person {
    ...
}
```

<br>
    
3. 자바 불변객체 종류

```
   String : 내부적으로 불변 문자 배열

   Wrapper Classes

   LocalDate, LocalTime, LocalDateTime

   UUID

   Enum

   Path
```

<br>

4. Record
   
   클래스 타입
   
   필드 자동 final 선언 (컴파일 시)
   
   getter, toString(), equals(), hashCode() 자동생성 (컴파일 시)
   
   용도 : 읽기 전용 데이터 클래스
   
   VO(Value Object) 을위해 나타난 타입같기도...

<br>

####  절대적 스레드 안전

  어떠한 런타임 환경에도 안전이 보장되어야 한다.

  Vector 예시 코드가 인상깊었다.

  내가 작성한 코드가 Vector 예시 처럼 예상치 못한 결과를 낼 수도 있으니 항상 주의해야할 듯 하다

  웬만해선 절대적 안전은 불변객체 뿐이지 않을까 
  
<br>

####  조건부 스레드 안전

  Vector, HashTable, syncronizedCollection() 으로 래핑한 경우 등

내가 작성한 작성할 코드도 여기

<br>

####  스레드 호환

  ArrayList, HashMap (사용자가 의도한대로 스레드 안전을 보장하도록 조치 가능)

<br>

####  스레드 적대적

  여러 스레드가 동시에 접근할 때 예기치 않은 결과 

  데드락(Deadlock), 경쟁 조건(Race Condition) , 교착 상태(Starvation)

######  Deadlock  : 서로가 점유한 자원을 기다리며 대기
######   Race Condition : 동일한 자원 동시 접근, 수정 (해결 : synchronized)
######  📝 Starvation  (해결 : 순위조정)

```JAVA
public class Ex {
    public static void main(String[] args) {
        Thread highPriorityThread = new Thread(() -> {
            while (true) {
                
            }
        });
        Thread lowPriorityThread = new Thread(() -> {
            while (true) {
                
            }
        });

        highPriorityThread.setPriority(Thread.MAX_PRIORITY);
        lowPriorityThread.setPriority(Thread.MIN_PRIORITY);

        highPriorityThread.start();
        lowPriorityThread.start();
    }
}
```


