# CH.13 스레드 안정성과 락 최적화


## 13.1 스레드 안정성

### 스레드 안정성 : 정의
1) 느슨한 정의 : "어떤 객체를 여러 스레드에서 동시에 안전하게 사용할 수 있을 때, 해당 객체를 *스레드-안전(thread-safe)* 하다고 표현한다."
   
2) 엄밀한 정의 by *Brian Goetz* (*Java Concurrentcy In Practice*)
```
여러 스레드가 한 객체에 동시에 접근할 때,
 - '어떤 런타임 환경에서든' 다음 두 조건을 모두 충족함과 동시에
 - '객체 호출 행위가 올바른(의도에 부합하는) 결과를 도출할 경우'
 이 객체를 스레드 안전하다고 표현한다.

1) 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요 없다.
2) 추가적인 동기화 수단이나 호출자 측(사용자)측에서 별도 조율이 필요 없다.
```
*Brian Goetz* 의 정의
- 굉장히 엄밀한 동시에 현실에 바로 적용 가능한 정의
- 하지만  동시에 굉장히 엄격하여 그대로 구현하기엔 여러 제약이 존재.
  - 따라서 실제론 이보단 다소 너그러운 정의를 사용한다.

1) 왜 *Thread-Safety* 가 중요한가?
   - 동시성 프로그래밍의 핵심 : 복수의 스레드가 공유 자원에 접근하거나 변경 혹은 저장 및 읽기/쓰기 연산을 시행한다는 것.
   - 이러한 상황에서 thread-safety를 보장하는 것 : 해당 프로그램이 *의미적으로(semantically)* <u>올바르게 작동함을 보장</u>하는 것.
   - 우리는 예상과 다르게 움직이는 무언가를 설계하는 사람이 아니라, 정확하게 예상하고 의도한 방향으로 움직이는 무언가를 설계하는 사람이기 때문에, 동시성 프로그래밍 환경에서 thread-safe 한 프로그램을 작성하는 것이 중요한 것.

### 자바 언어의 스레드 안정성
- 자바는 언어의 설계 시점부터 스레드를 지원했기 때문에 스레드 안정성 확보가 용이한 편.
- 그렇지만 모든 API 및 변수 타입이 완벽하게 스레드 안정적인 것은 아님.
- 그렇기 때문에 스레드 안정성을 '안정성의 정도'에 따라 다음의 다섯 가지 단계로 나누어 살펴보는 것이 용이함.

1. 불변(Immutable)
2. 절대적 스레드 안전 : Brian Goetz 의 스레드 안정성 정의 충족하는 수준
3. 조건부 스레드 안전
4. 스레드 호환
5. 스레드 적대적

#### ***불변(Immutable)***
> *불변 객체* 
> 
> 생성된 이후에 상태가 변경될 수 없는 객체를 말한다.
> 
> <small>출처 : Oracle Java SE Document</small>

- 가장 높은 수준의 스레드 안정성 보장
  - 이는 생성된 후에 어떠한 변경도 허용되지 않는 특성을 고려했을 때 자명한 사실.


#### ***절대적 스레드 안전***
- *Brian Goetz* 의 스레드 안정성 조건을 충족하는 수준을 의미한다.
  - 본래 '스레드 안정성' 이라는 이름으로 소개된 수준이지만, 다른 수준의 안정성과의 구분을 용이하게 하기 위해 이 책 한정 사용하는 표현.
- 즉, 다음의 조건을 만족하는 스레드 안정성을 의미
   - *어떤 런타임 환경에서든 호출자가 추가적인 동기화 조치를 할 필요 없음*
   - 이는 많은 비용 필요로 하거나 상황에 따라 구현 불가한 수준일 수 있음.

- *절대적 스레드 안전성* 을 Java에서 갖출 수 있는 방안은 대표적으로 아래의 두 가지
  - 하나, `synchronized` 키워드 활용하여 필요한 부분의 연산들이 원자적으로 실행되도록 강제하는 것.
  - 둘, `Collection` 일 경우 원소 변경 시 마다 새로운 snapshot 생성하여 공유 변수에 대한 수정이 동시에 발생하지 않도록 예방하는 것
    - ex. `ArrayDeque` 구현 클래스를 살펴보면 새로운 원소 추가시 마다 새로운 `Object[] es` 생성하고 해당 변수로 옮겨 담은 후 참조 갱신하는 것을 확인할 수 있다.
      - 하지만 `ArrayDeque`는 thread-safe 하지 않으므로 참고 바람.

#### 조건부 스레드 안전
 - 일반적으로 '스레드 안전하다' 라고 표현하는 수준의 스레드 안정성
 - <u>단일한 작업(메서드)에 대해 스레드 안정성을 보장하는 수준</u>을 의미한다.
   - ex. `Vector` 컬렉션의 `add()`, `get()`, `size()` 연산, `HashTable` 컬렉션 등.
 - 하지만 이와 같은 <u>단일 메서드가 연속적으로 발생할 경우 별도의 동기화 보장 조치가 필요</u>하다.

#### 스레드 호환
- 객체 자체로는 스레드-안정적이지 않은아, 호출자의 별도 조치 시 스레드 안정성을 확보할 수 있는 수준.
- 이 수준부터 '스레드 안정적이지 않다' 라고 일반적으로 표현한다.
- ex. `ArrayList`, `HashMap` -> 각각 `Vector` 와 `HashTable`의 스레드 호환 버전.
  - `HashMap`의 경우 별도로 `ConcurrentHashMap` 컬렉션 존재. 

#### 스레드 적대적
- 호출자가 별도의 조치를 취하더라도 멀티 스레드 환경에서 안전하게 사용할 수 없는 수준.
- ex. `Thread.suspend()` & `Thread.resume()` : 한 스레드를 공유하는 두 스레드가 각각 공유 스레드에 대해 해당 두 가지 연산을 각각 다르게 동시에 시행할 경우 바로 교착 상태로 돌입한다.
  - 이러한 이유로 Deprecated.


### 스레드 안정성 구현
- 우리가 어떤 자바 프로그램을 작성할 때, 해당 프로그램이 스레드-안정성을 갖추도록 강구하는 방법은 다음의 두 가지 차원에서 가능
   - 하나, 코드 차원에서의 스레드 안정성 강구
   - 둘, JVM이 제공하는 동기화 및 락 메커니즘 활용.
- 이 중, JVM이 제공하는 동기화 및 락 메커니즘에는 대표적으로 두 가지가 존재한다.
  - 상호 배제(Mutual Exclusion) 동기화
  - 논블로킹(Non-blocking) 동기화

#### 상호 배제 동기화(Mutual Exclusion)

> ***임계영역(Critical Section)***
> - 공유 자원이 존재하고 이에 대한 동시 접근 및 사용이 발생 가능한 경우, \
>   해당 공유 자원에 대한 경합 상황이 발생하지 않도록 오직 하나의 사용 주체(ex. 스레드)에 의해 독점이 가능하도록 허용한 영역
> - 즉, 동시 접근이 금지된 영역을 의미한다.
> 
> <small> 출처 : Wikipeida </small>


> ***상호 배제(Mutual Exclusion, Mutex)***
> - 동시성 프로그래밍 환경에서 공유 자원에 대해 <u>오직 하나의 작업 주체(ex. 스레드)만이 접근 및 사용 가능하도록</u> 함으로써, 공유 자원에 대한 경합 상황을 피하고 스레드 안정적으로 실행될 수 있도록 하는 *알고리즘*
>
> <small> 출처 : Wikipeida </small>


> *상호 배제(Mutual Exclusion)* 와 *동기화(Synchronization)* 의 차이
> - 두 용어 모두 자바 동시성 프로그래밍 맥락에서 사용될 때 크게 두 가지 공통 키워드를 갖는다.
>> 1) 다수의 스레드가 공유하는 공유 자원에 대해
>> 2) 오직 한 번에 하나의 스레드만 접근 및 사용, 변경 가능하도록 하다.
>
> - 도대체 둘의 차이가 무엇인가, 헷갈려 찾아보았더니
>> - **동기화(Syncronization)** : 공유 자원에 대해 한 번에 오직 하나의 스레드만이 정해진 시간에 접근 가능하도록 하는 *방식* 혹은 *절차* (목적)
>> - **상호 배제** : 동기화를 구현하는 어떤 *알고리즘* (수단). 세마포어 또한 동기화 구현 알고리즘의 일종이다.

자바에서는 크게 두 가지 방식으로 상호 배제 동기화를 제공한다.

##### `synchronized` 키워드
- javac 가 이 키워드로 선언된 객체 및 복수의 연산을 묶은 블록 부분을 컴파일 할 시, \
  해당 부분의 앞 뒤로 `monitorenter`, `monitorexit` 라는 바이트코드 명령어를 생성하여 추가한다.
- 생성된 바이트코드를 통해 다음과 같은 절차로 동기화를 실현한다.
  - `monitorenter` : 해당 명령어 실행 시 우선 해당 블럭 및 객체에 대한 락을 얻으려 시도한다.
    - 해당 객체 및 블록이 잠겨있지 않거나, 이미 현 스레드가 해당 락 소유 중일 경우 : 해당 객체의 object header의 mark word 부분에 위치한 lock counter 값이 1 증가.
  - `monitorexit` : 해당 명령어 실행 시 lock counter 값을 1 감소 시킨다.
  - `lock counter  == 0` : 락이 해제된다.
- 해당 키워드로 락을 소유한 스레드의 작업이 완전히 종료될 때 까지(`monitorexit` 명령어 통과 시점까지), 다른 스레드의 접근을 원천 차단한다.

- 장점
  - 자바 구문 수준의 동기화 수단 -> 아주 명확하고 간결
  - 재진입(Re-Entrant or Re-entrance)이 가능하다.
  - 불가피한 문맥 교환으로부터 발생하는 성능 오버헤드가 많이 개선 되었다.(JDK 6 기점)
    - 스레드 블록이 필요하다고 운영체제에 알리기 전 `busy waiting` 및 `spinning` 코드를 추가하여 최대한 문맥 교환 횟수를 줄이는 방식 도입 -> 가장 대표적인 최적화 방안 중 하나.
- 단점
  - 그럼에도 불구하고 성능 오버헤드에 대한 고민을 완전히 떨쳐내기 어려울 수 있다.
  - 인터페이스 수준에서 가능한 유연하고 확장적인 사용 방식을 도입하기 어렵다. -> 언어 차원에서 제공하는 방식으로 한정됨.


##### `java.util.concurrent.locks.Lock`
- JDK 5부터 도입된 인터페이스 수준의 상호 배제 동기화 구현 방안.
- `Lock` 인터페이스를 제공함으로써 프로그래밍 차원에서의 <u>논블록 기반 상호 배제 동기화 구현</u>이 가능하도록 함.
- 대표적인 예 : `ReentrantLock`
  - `synchronized`와 마찬가지로 재진입 가능
  - 하지만 인터페이스이기 때문에, 프로그램 레벨에서 구현되는 만큼 보다 높은 확장성을 가진다.
    - 페어 락(fair lock) : 락 획들을 시도한 시간 순서대로 다음 락을 가질 스레드 결정. 생성자에서 선택 가능.
    - 대기 중 인터럽트 : 락을 소유한 스레드가 오랜 시간 락을 해제 하지 않을 때 같은 락 얻기 위해 대기 중인 다른 스레드들이 락을 포기하고 다른 일을 할 수 있도록 한다.
    - 둘 이상의 조건 지정 가능 : `Condition` 객체를 통해 락 설정과 해제를 조건에 따라 시행 가능

     

## 13.2 락 최적화