## 13.1 들어가며
- 절차적 프로그래밍(Procedural Programming) : 프로시저나 함수를 활용해 프로그램을 순차적으로 처리. 프로그램 전체가 유기적으로 연결되어 작업 수행
- 객체지향 프로그래밍(Object Oriented Programming) : 클래스를 정의하고 객체 생성해 로직 구성. 객체 간 상호작용으로 문제 해결<br>
-> 서로 반대되는 개념이 아니며 상호보완적으로 활용 가능
<br><br>


## 13.2 스레드 안전성
- 여러 스레드가 한 객체에 동시에 접근할 때 어떤 런타임 환경에서든 2가지 조건을 충족하면서 객체를 호출하는 행위가 올바른 결과를 얻는 것<br>
  case1. 특별한 스레드 스케줄링이나 대체 실행 수단을 고려할 필요 X<br>
  case2. 추가적인 동기화 수단이나 호출자 측에서 조율 필요 X<br>
- 동기화 등의 안전장치를 코드 자체에 완벽하게 내장해서 호출자가 안전하게 사용할 수 있어야 함
<br>

### 13.2.1 자바 언어의 스레드 안전성
**스레드 안전함 정도**
- 불변
  - 객체 자체의 메서드 구현과 호출자 모두에서 안전장치 없어도 스레드 안전
  - 자바에서 기본 데이터 타입은 final로 정의하면 불변성 보장
  - ex) java.lang.String 객체 -> 원래 값은 냅두고 새로 생성한 String 객체 반환
  - ex) 열거 타입. but, Number의 하위 클래스 AtomicInteger, AtomicLong은 제외 -> 스레드 안전하게 동작하지만 값을 바꿀 수 있음

- 절대적 스레드 안전
  - 13.2에서의 스레드 안전성 조건 만족
  - synchronized를 쓰려면 동기화 블록으로 감싸야 함

- 조건부 스레드 안전
  - 단일한 작업을 별도 보호조치 없이 스레드로부터 안전하게 수행
  - 특정 순서로 연달아 호출할 때는 추가 동기화 필요
  - ex) Vector, HashTable, Collections클래스 synchronizedCollection()

- 스레드 호환(스레드 안전하지 않다)
  - 객체 자체는 스레드에서 안전하지 않지만 호출자가 적절히 조치하면 멀티스레드 환경에서 안전하게 사용할 수 있는 것
  - 자바 클래스 대부분 여기에 속함. ArrayList, HashMap 등

- 스레드 적대적
  - 호출자가 동기화 조치를 해도 멀티스레드 환경에서 안전하게 사용할 수 없는 것
  - Thread 클래스 suspend(), resume() -> 동시에 사용하면 메서드를 동기화 해도 대상 스레드는 교착 상태에 빠진다
<br><br>


### 13.2.2 스레드 안전성 구현
- 상호 배제 동기화
  - 상호 배제 : 원인, 수단 / 동기화 : 결과, 목적
  - 가장 일반적이면서 중요한 동시성 보장 수단
  - synchronized
    - javac로 컴파일하면 monitorenter, monitoexit 바이트코드 명령어 생성 -> 각각 동기화 블록 전후 실행되고, 락으로 사용할 객체를 참조 타입 매개 변수로 받는다.
    - monitorenter 실행하고 객체가 풀려있거나 현재 스레드가 이미 소유중이면 락 카운터 +1. monitoexit는 -1 -> 카운터가 0이 되면 락 해제
    - synchronized는 무거운 작업이라 필요할 때만 제한적으로 사용
  - JDK5부터는 java.util.concurrent.locks.Lock으로 새로운 상호 배제 동기화 제공
  - ReentrantLock
    - synchronized처럼 재진입이 가능한 락
  - 기본 동기화 기능으로 충분하면 ReentrantLock 말고 synchronized 사용
<br>
