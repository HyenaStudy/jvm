# 13.3

## 1. 락 최적화

### (1) 스핀 락
스레드가 락을 획득할 때까지 **반복적으로 시도**하는 락<br />
잠깐의 대기 시간 동안 락을 획득하는 경우에 효율이 좋은 편이다.<br />
다만 결국 락 획득을 시도한다는 것이 CPU를 계속 점유하므로 과소비의 우려가 있다.

### (2) 락 제거
락 자체가 결국 동기화를 위한 수단이므로 리소스를 소모한다.<br />
그렇기 때문에 단일 스레드 혹은 락이 불필요한 상황에서 굳이 락을 유지할 필요가 없다.<br />

직접 코드로 확인해보고 싶었는데, 정확히는 JVM이나 JIT나 실행 시점에 락을 제거한다고 한다.<br />
그래서 JVM 로그를 확인해보는 방법을 먼저 익혀야 한다...(어우 어려워)

### (3) 락 범위 확장

여러 동기화 작업을 하나의 락으로 통합하여 처리하는 방법이다.<br />

```java
private int count = 0;

synchronized void add1() {
  count++;
}

synchronized void add2() {
 count++;
}
```

스레드에서 `count` 변수의 가산을 위해 위의 스레드가 필요로 한다고 가정하자.<br />
위 코드에 따르면 각각의 메소드 호출에 대하여 스레드 당 2번씩 동기화가 발생한다.<br />
이것을 하나로 묶어본다.

```java
private int count = 0;

synchronized void addAll() {
  add1();
  add2();
}

void add1() {
  count++;
}

void add2() {
 count++;
}
```

위의 코드는 두 개의 `synchronized` 메소드를 하나로 묶은 예시가 된다.<br />
이런 경우여도 똑같이 안전한 가산이 가능하며 스레드 당 1번씩만 동기화가 발생하기 때문에 효율성을 챙길 수 있다.<br />
이런 케이스를 **락 범위 확장**이라고 한다. 다만, 과도하게 사용하면 병목 현상이 유발될 수 있다.

### (4) 경량 락

락 경쟁은 필연적으로 리소스 소모를 유발하는데, 이를 줄이기 위해 고안된 매커니즘 중 하나가 경량 락이다.<br />
기존의 `synchronized`나 `ReentrantLock` 등은 락 획득을 위한 자원 소모 경쟁을 유발하게 된다.<br />
경량 락은 이런 통상적으로 락이 붕 뜨는, 대기 시간에 효율적으로 리소스를 활용하기 위한 동적인 락 전환이 기본 골자인데, 보통 락 경쟁이 심화될 수록 경량 락에서 중량 락으로 전환되며 이런 동적인 락 전환에는 `Atomic` 관련 클래스의 원자적 연산에서 봤던 CAS(Compare And Swap)를 기반으로 이루어진다.

사실 우리가 신경 쓸 필요는 없는 편이긴 하다. Java 9 이후부터는 JVM이 자동으로 최적화해주기 때문...

### (5) 편향 락

얘는 더하다. 아예 15버전에서 `deprecated` 선언이 됐기 때문...<br />
그래도 간단히 개념만 알고 넘어가자면 편향 락은 단일 스레드가 특정 객체에 대해 지속적으로 락을 획득하는 경우 성능을 최적화하는 방식 정도로만...<br />
참고로 왜 삭제됐냐면, 얘는 경쟁이 작을 수록 효율적인데 경쟁이 작을 수록 락을 쓸 의미가 없지 않나..? 라는 생각이 든다.
