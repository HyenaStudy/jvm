### 12.1

컴퓨터의 연산 성능과 저장 통신 성능의 격차가 크기 때문에 멀티태스킹이 필수적이다. 또, 같은 작업에 대해서 여러 스레드를 동시에 운용하면 효율이 높아지고 처리량이 증가한다. 이때 스레드 간의 경합이 최소화되도록 관리해야 한다. 해당 장에서는 프레임워크에서 제공하는 동시성 도구들과 경합 발생 시 생기는 문제와 그 해결책을 다룬다.

### 12.2

[문제] 컴퓨터 작업에서 메모리 I/O가 필수적임 , 프로세서 속도에 비해 메모리 처리 속도가 너무 느림

[과정] 각 프로세서가 자신만의 캐시를 갖춘 공유 메모리 멀티 프로세서 시스템 사용

[결과]데이터를 메인 메모리로 동기화할 때 어느 프로세서의 데이터를 기준으로 삼아야 하는가?

- MSI, MESI (일리노이 프로토콜)
- MOSI
- 시냅스 (Synapse)
- 파이어플라이(Firefly)
- 드래곤 프로토콜 (Dragon)

이처럼 캐시를 늘리는 방법 말고 비순차 실행 최적화를 사용하는 방법도 존재

### 12.3

자바는 자바 메모리 모델을 사용하여 다양한 플랫폼의 메모리 모델로부터 프로그램을 보호하고, 플랫폼에 무관하게 일관된 메모리 접근 방식을 사용할 수 있다. 이는 JVM이 일관된 메모리 방식을 제공하기 때문이다.

**메인 메모리와 작업 메모리**

- 자바 메모리 모델의 목적: 가상 머신의 메모리에서 변수의 값을 저장하고 가져오는 규칙을 정하는 것에 중점
(이때 변수에는 인스턴스 필드, 정적 필드, 배열 객체의 원소만 포함되며, 지역 변수와 메서드 매개변수는 포함되지 않음. 이는 지역 변수와 매개변수가 스레드별 고유 공간을 사용하기 때문)
- 자바 메모리 모델은 모든 변수가 메인 메모리에 저장된다고 규정한다.
- 각 스레드는 자체 작업 메모리를 갖고, 프로세서의 캐시와 비슷한 역할을 수행한다.
- 각 스레드는 메인 메모리에서 데이터를 복사하여 작업 메모리에서 사용하며, 스레드끼리는 서로의 작업 메모리에 직접 접근할 수 없고 반드시 메인 메모리를 통해 값을 전송해야 한다.

**메모리간 상호작용**

8가지 규칙 존재

- **잠금(lock)**: 변수를 특정 스레드만 사용할 수 있도록 설정.
- **잠금 해제(unlock)**: 잠긴 변수를 다른 스레드가 사용할 수 있도록 해제.
- **읽기(read)**: 메인 메모리의 변숫값을 작업 메모리로 가져옴.
- **적재(load)**: 읽기 연산으로 가져온 값을 작업 메모리에 복사.
- **사용(use)**: 작업 메모리의 변숫값을 실행 엔진으로 전달.
- **할당(assign)**: 실행 엔진에서 받은 값을 작업 메모리에 할당.
- **저장(store)**: 작업 메모리의 값을 메인 메모리로 전송 준비.
- **쓰기(write)**: 작업 메모리의 값을 메인 메모리에 기록.

 **volatitle 변수용 특별 규칙**

- volatitle키워드는 자바 가상 머신이 제공하는 동기화 메커니즘
- 모든 스레드에서 이 변수를 투명하게 볼 수 있다. (가시성)
- 각 스레드의 작업 메모리에서는 volatitle 변수의 일관성에 문제가 없지만, 물리적 관점에서 아닐 수 있음 )
- 문제점
    
     
    
    ```jsx
    public class VolatileTest {
        public static volatile int race = 0;
    
        public static void increase() {
            race++;
        }
    
        private static final int THREADS_COUNT = 20;
    
        public static void main(String[] args) {
            Thread[] threads = new Thread[THREADS_COUNT];
            for (int i = 0; i < THREADS_COUNT; i++) {
                threads[i] = new Thread(new Runnable() {
                    @Override
                    public void run() {
                        for (int i = 0; i < 10000; i++) {
                            increase();
                        }
                    }
                });
                threads[i].start();
            }
    
            // 다른 모든 스레드가 종료될 때까지 대기
            while (Thread.activeCount() > 1)
                Thread.yield();
    
            System.out.println(race);
        }
    }
    
    ```
    
    - race 연산 : 값 읽기 → 1 증가 → race에 저장
    - 두스레드가 동시에 읽고 각각 1을 증가시킨 후 저장하면 충돌 발생 → 원자적이지 않음
    - 변수값을 수정하는 스레드는 항상 하나, 다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않음에 대한 규칙 위반
- 명령어 재정렬 최적화를 막아준다.
    - 명령어 재정렬 : 컴파일러나 프로세서가 플로그램을 실행할 때 성능 최적화를 위해 명령어 실행 순서 변경
    - 멀티스레드에서는 동시성 문제를 피하기 위해 제어가 필요함

volatitle의 장점

- 다른 동기화 도구보다 코드를 더 빠르게 수행
