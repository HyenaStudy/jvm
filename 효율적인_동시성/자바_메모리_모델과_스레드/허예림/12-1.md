### 하드웨어 멀티태스킹

컴퓨터의 연산 성능과 저장 통신 성능의 격차가 크기 때문에 멀티태스킹이 필수적이다. 또, 같은 작업에 대해서 여러 스레드를 동시에 운용하면 효율이 높아지고 처리량이 증가한다. 이때 스레드 간의 경합이 최소화되도록 관리해야 한다. 해당 장에서는 프레임워크에서 제공하는 동시성 도구들과 경합 발생 시 생기는 문제와 그 해결책을 다룬다.

### 자바 다중 스레드 환경

자바는 자바 메모리 모델을 사용하여 다양한 플랫폼의 메모리 모델로부터 프로그램을 보호하고, 플랫폼에 무관하게 일관된 메모리 접근 방식을 사용할 수 있다. 이는 JVM이 일관된 메모리 방식을 제공하기 때문이다.

**메인 메모리와 작업 메모리**

- 자바 메모리 모델의 목적: 가상 머신의 메모리에서 변수의 값을 저장하고 가져오는 규칙을 정하는 것에 중점
(이때 변수에는 인스턴스 필드, 정적 필드, 배열 객체의 원소만 포함되며, 지역 변수와 메서드 매개변수는 포함되지 않음. 이는 지역 변수와 매개변수가 스레드별 고유 공간을 사용하기 때문)
- 자바 메모리 모델은 모든 변수가 메인 메모리에 저장된다고 규정한다.
- 각 스레드는 자체 작업 메모리를 갖고, 프로세서의 캐시와 비슷한 역할을 수행한다.
- 각 스레드는 메인 메모리에서 데이터를 복사하여 작업 메모리에서 사용하며, 스레드끼리는 서로의 작업 메모리에 직접 접근할 수 없고 반드시 메인 메모리를 통해 값을 전송해야 한다.

**메모리간 상호작용**

8가지 규칙 존재

- **잠금(lock)**: 변수를 특정 스레드만 사용할 수 있도록 설정.
- **잠금 해제(unlock)**: 잠긴 변수를 다른 스레드가 사용할 수 있도록 해제.
- **읽기(read)**: 메인 메모리의 변숫값을 작업 메모리로 가져옴.
- **적재(load)**: 읽기 연산으로 가져온 값을 작업 메모리에 복사.
- **사용(use)**: 작업 메모리의 변숫값을 실행 엔진으로 전달.
- **할당(assign)**: 실행 엔진에서 받은 값을 작업 메모리에 할당.
- **저장(store)**: 작업 메모리의 값을 메인 메모리로 전송 준비.
- **쓰기(write)**: 작업 메모리의 값을 메인 메모리에 기록.

### 멀티태스킹 처리 방법

[문제] 컴퓨터 작업에서 메모리 I/O가 필수적임 , 프로세서 속도에 비해 메모리 처리 속도가 너무 느림

[과정] 각 프로세서가 자신만의 캐시를 갖춘 공유 메모리 멀티 프로세서 시스템 사용

[결과]데이터를 메인 메모리로 동기화할 때 어느 프로세서의 데이터를 기준으로 삼아야 하는가?

- MSI, MESI (일리노이 프로토콜), MOSI, 시냅스 (Synapse), 파이어플라이(Firefly), 드래곤 프로토콜 (Dragon)로 캐시를 늘리거나 효율 극대화

캐시를 늘리는 방법 말고 비순차 실행 최적화를 사용하는 방법으로 해결 가능

- 비순차 실행 최적화 : 프로세서에서 프로그램 명령어를 코드에 작성된 순서와 다르게 실행하여, 프로세서의 성능을 최대한 활용 → 동시성 문제 → 메모리 베리어, 뮤텍스 사용
    - 메모리 베리어 : 프로세서가 명령어 재정렬을 수행하는 데 제한을 두어 메모리 접근의 순서를 보장하는 기법 (가시성)
    - 뮤텍스 : 특정 자원을 한 번에 하나의 스레드 또는 프로세스만 접근 가능하도록 락을 걸어, 동시성 문제를 방지하고 데이터 일관성을 유지하는 역할 (원자성)
- 명령어 재정렬 : 프로세서가 성능을 최적화하기 위해 프로그램 내의 명령어 순서를 변경하는 것 → JVM에서 멀티 스레딩 환경에서의 명령어 실행 순서를 보장하기 위해 volatile과 synchronized 사용

**선 발생 원칙**

- 자바 메모리 모델에서 정의 된 두 작업의 수행 순서 관계를 정의하는 원칙
- 다중 스레드 환경에서 데이터 일관성 보장이 목적
- 해결 방법
    - 게터/세터 메서드를 synchronized메서드로 생성 → 공유 변수에 대한 접근을 동기화하여 순서보장
    - 값을 volatile로 선언 → 변수의 최신 값을 항상 모든 스레드가 볼 수 있도록 보장하여 일관성 유지.

### volatile

- volatile키워드는 자바 가상 머신이 제공하는 동기화 메커니즘
1. 모든 스레드에서 이 변수를 투명하게 볼 수 있다. (가시성) → 여러 스레드간 변수를 항상 최신 상태로 유지
    - 문제점
        
        ```jsx
        	public class VolatileTest {
            public static volatile int race = 0;
        
            public static void increase() {
                race++;
            }
        
            private static final int THREADS_COUNT = 20;
        
            public static void main(String[] args) {
                Thread[] threads = new Thread[THREADS_COUNT];
                for (int i = 0; i < THREADS_COUNT; i++) {
                    threads[i] = new Thread(new Runnable() {
                        @Override
                        public void run() {
                            for (int i = 0; i < 10000; i++) {
                                increase();
                            }
                        }
                    });
                    threads[i].start();
                }
        
                // 다른 모든 스레드가 종료될 때까지 대기
                while (Thread.activeCount() > 1)
                    Thread.yield();
        
                System.out.println(race);
            }
        }
        
        ```
        
        - race 연산 : 값 읽기 → 1 증가 → race에 저장
        - 두스레드가 동시에 읽고 각각 1을 증가시킨 후 저장하면 충돌 발생 → 원자적이지 않음
        - 변수값을 수정하는 스레드는 항상 하나, 다른 상태 변수와 관련한 불변성 제약 조건에 관여하지 않음에 대한 규칙 위반
2. 명령어 재정렬 최적화를 막아준다.
    - 명령어 재정렬 : 컴파일러나 프로세서가 플로그램을 실행할 때 성능 최적화를 위해 명령어 실행 순서 변경
    - 멀티스레드에서는 동시성 문제를 피하기 위해 제어가 필요함
- volatile의 장점 : 다른 동기화 도구보다 코드를 더 빠르게 수행

**volatile로 선언되지 않은 Long과 Double**

- 64비트 데이터는 가상 머신이 두 개의 32비트 연산으로 나누어 처리하기에, 여러스레드가 공유하고 동시 접근 시 반만 수정된 값을 읽을 위험이 있다.
- JDK 9부터 모든 데이터 타입에 원자적으로 접근하도록 실험적 매개변수 추가
- 따라서 스레드 경합이 일어나는 경우가 아니면 volatile로 선언할 필요 없음

### Syncronized

- 자바 메모리 모델에서 기본 데이터 타입은 원자적 접근을 보장하며, Syncronized로 동기화된 블록은 monitorenter와 monitorexit 명령어로 원자성을 보장한다.
- 락을 이용해 한 번에 하나의 스레드만 해당 블록이나 메서드를 실행할 수 있게 하므로 안전하게 데이터에 접근 → 락을 획득하고 해제하는 과정에서 volatile보다 속도가 느릴 수 있음

- 결론
    
    단일 읽기 / 쓰기 처럼 원자성 보장이 필요없는 경우 → volatile
    
    복합 연산이 필요하고 원자성 보장이 필요한 경우 → synchronized
    

### 12.4 자바와 스레드

**스레드 구현 방법**

1. **커널 스레드 구현 (1:1 구현)**
    - 커널 스레드: 운영체제에서 직접 지원하는 스레드로, 스레드의 작업을 각 프로세서에 매핑하는 역할을 수행. 이를 통해 운영체제가 여러 작업을 동시에 처리할 수 있음.
    - 경량 프로세스 (LWP, Light Weight Process): 일반적인 개념의 스레드를 의미하며, 커널 스레드의 고수준 인터페이스로 구현. 커널 스레드를 기반으로 생성되며, 실행 비용이 높고, 시스템 자원(예: 커널 스레드의 스택 공간 등)을 소모하므로 개수에 제한이 있음.
    - 일대일 스레딩 모델: 경량 프로세스와 커널 스레드가 1:1 관계로 매핑되는 구조를 의미하며, 이 모델에서경량 프로세스는 커널 스레드의 지원을 받아 독립적으로 스케줄링됨.
2. 사용자 스레드 구현 (1:N 구현)
    - 사용자 스레드: 커널 스레드와 달리 사용자 공간에서 생성되고 처리되는 스레드로, 대부분의 스레드를 의미한다. 커널 모드 전환 없이 처리되어 생성, 소멸, 전환 등의 비용이 낮다.
    - 장점: 시스템 커널의 자원이 필요 없기 때문에 더 많은 스레드를 지원할 수 있고, 실행 비용이 적음.
    - 단점: 시스템 커널의 직접적인 지원을 받지 않으므로 커널 수준에서의 스케줄링이나 자원 관리가 어려우며, 특정 상황에서 성능 문제가 발생할 수 있음.
3. 사용자 스레드와 경량 프로세스의 하이브리드 구햔 (M:N 구현)
    - 사용자 스레드와 경량 프로세스의 공존 : 사용자 스레드는 사용자 영역에서 경략 프로세스는 커널 스레드와 사용자 스레드간 가ㅏ교 역할
    - 사용자 스레드의 생성, 소멸, 전환 비용이 낮고 동시성 규모가 커질 수 있다.

**자바 스레드 스케줄링**

- 자바에서도 선점형 스케줄링을 사용하고 스레드 우선순위를 설정할 수 있다.
- 운영체제와 단계가 달라 의존할 순 없다.

**상태 전이**

- 신규 : 생성 후 대기
- 실행 중 : 실행 시간 할당 대기 or 실행 중
- 무기한 대기 : 실행 시간 할당 X
- 시간 제한 대기 : 일정 시간이 지나면 자동적으로 깨어나는 대기 상태
- 블록 : 다른 스레드가 해당 락을 해제할 때까지 대기
- 종료 : 실행 마침

https://jbground.tistory.com/73
