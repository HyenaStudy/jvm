## 멀티스레드환경에서의_프로그래밍

<br>

### 스레드와 성능 


> <br>
> 프로세서, 스레드가 많을 수록 성능이 증가하는 것은 아니다 

<br>
이 둘은 선형적인 관계가 아니며,<br><br>

스레드 간의 **컨텍스트 스위칭**, **동기화**, **자원 경쟁** 등의 요소들이 그 이유이다.

<br><br>

####  　　컨텍스트 스위칭 오버헤드  
<br>

　　현재 상태를 저장하고 다른 프로세스나 스레드로 전환(로드)될때 발생하는 비용이 가볍지 않다.

　　프로세스보다 스레드가 상대적으로 비용이 적게들 뿐이지, 

　　스레드 갯수가 많아질수록 스위칭 빈도도 높아질 것이고 오버헤드가 누적되어

　　결과적으로는 성능 저하로 이어 질 수 있다.

<br><br>

####  　　동기화의 3가지 키워드
<br>

　　앞선 글에서 알 수 있었던 메인메모리영역을 공유하게되는 부분에서

　　캐시 일관성과 동기화 이슈를 예상 할 수 있다.

　　이를 해결하는 방법으로는 한번에 하나의 스레드만 공유 자원에 접근 할수 있도록

　　제어함으로서 데이터 일관성을 유지할 수 있다.

　　많은 스레드가 많은 양의 데이터를 공유하는 경우

　　동기화 과정에서 병목현상으로 이어져 성능을 저하시킬 가능성이 높다.

<br>

###  멀티 스레딩 환경에서의 프로그래밍


###### 　　 :::::　 멀티스레딩 환경에서 맞닥뜨릴만한 문제들을 줄이고 성능 저하를 최소화 할수 있는 방법엔 뭐가 있을까?

<br><br>

####  　　성능 최적화하기

<br>

- 　　스레드풀 사용  (스레드 수 관리, 재사용 등)
   
- 　　동기화 최소화  ( **syncronized** , Atomic class) (비동기 프로그래밍, 락 최소화)
    
- 　　어플리케이션 수준에서 작업을 효율적으로 분할하고 병렬처리가 가능하도록 설계 ( 각 스레드가 독립적으로 작업하게끔 )
  
- 　　cpu수에 적적한 스래드 갯수 분배
  
- 　　자원경쟁 해결 ( 큐, lock free 인터페이스 활용 )

<br>

###  동기화


###### 　　 :::::　 동기화의 3가지 키워드 syncronized , volatile , Atomic class


  <br><br><br><br>

- 꼭 필요한 곳에 꼭 필요한 만큼만 적용해야 성능 저하 이슈를 최대한 피할 수 있다.
- 수정이나 상태변경에만 걸고, 읽는 작업은 동기화하지않는다.
- 전용 락 객체를 사용해 세밀하게 관리한다.
- 좀더 세밀하게 동기화를 제어하고싶다면 ReentrantLock 인터페이스를 사용하자
  - 시간, 중간에 해제하거나 여러 락 사용시에 활용해보자 
- 
