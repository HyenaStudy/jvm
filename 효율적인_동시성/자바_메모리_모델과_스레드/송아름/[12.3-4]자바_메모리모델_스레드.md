## 자바 스레드_자바 메모리모델 

<br>

#### 커널 스레드

　　CPU 스레드는 CPU에서 실제 실행되는 작업 단위이며 

　　커널 스레드는 커널레벨에서 이 스레드들을 관리하는 기능을 제공하는 스레드 라고 생각하면 될것 같다

　　커널 스레드도 결국 CPU에서 실행되며, CPU 스레드로 할당되어 작업을 수행하게 된다.

　　실질적인 스케줄링 대상도 커널스레드이다.

　　커널 스레드와 사용자 스레드는 CPU 스레드로 실행되지만, 

　　OS단계에서 실행되냐 어플리케이션단계에서 실행되냐 차이라고 한다.


<br>

#### 자바 스레드와 JVM

###### 　　 :::::　 JVM은 하드웨어 수준의 최적화와 협력을 통해 멀티스레딩을 세밀하게 조작 할수 있게 해준다.　 :::::

　　자바 스레드는 커널 스레드와 매핑되어 프로세서의 자원을 할당받을 수 있다.
  
　　OS에서는 작업단위로 스레드로 자원을 할당하고,
  
　　JVM은 운영체제의 스레드를 기반으로 실행되기 때문에, 기존 스레드 실행과정을 거치되
  
　　자바 어플리케이션 레벨에서 자바스레드들을 좀 더 세밀한 제어가 가능하도록 해준다.
  
<br>
　　JVM은 
  
  <br>
  
　　비즈니스 로직을 스레드로 실행하거나,
  
　　스레드 풀을 활용해 스레드 사용을 최적화하거나,
  
　　우선순위를 정할 수도 있으며,
  
　　스레드 간의 동기화를 좀더 세밀하게 다룰 수 있고,
  
　　스레드의 상태를 세밀하게 제어할 수 있는 등,

　　자바 스레드(사용자스레드)를 제어하고 관리함으로써 
  
　　어플리케이션 단게에서의 성능최적화와 리소스를 효율적으로 사용하도록 도와준다.
  

　　이부분은 OS에서 프로세서 스레드를 관리할 때 추구하는 방향성과 동일한 것같다.
  
<br>

#### 자바 스레드와 메인메모리


###### 　　 :::::　 멀티 프로세싱과정에서 캐시일관성의 문제가 생기는 이유와 자바 멀티스레딩의 동시성 문제는 비슷한 맥락인것 같다　 :::::
![image](https://github.com/user-attachments/assets/dc4319d8-9591-4e2c-aa27-33b72027d018)|![image](https://github.com/user-attachments/assets/dcf24d9c-2af9-41cc-975f-0da0a635ee32)
---|---|

　　이전 12.2 장의 멀티 프로세서의 캐시일관성에서 각각의 프로세서가 가지고있는 데이터가 다른경우 
  
　　메인 메모리에 동기화하는 과정이 간단히 해결되지 않았고

　　멀티 스레드에서도 스레드마다 가지고있는 각각의 데이터들이 메인메모리에 동기화될 때 역시
  
　　예상한 값과 전혀 다른 값이 저장 될 수도 있을 것이다.
  
<br>

#### 동시성 문제 해결 3가지 키워드

- syncronized
  - 성능 저하 이슈
  - 가장 작은단위로 걸것(락 최소화)
  - 여러 스레드가 동시에 접근할 가능성이 많을때는 Atomic class로 성능저하 최소화
  - 간단함
  - 복잡한 연산이나 다중객체간 데이터일관성 보장이 필요할때 (복잡한 락관리)
  
- volitile
  - 순서보장 (재정렬 최적화 방지)
  - 캐시말고 메모리에 저장 -> 가시성을 보장한다
  - 메모리에서 바로 읽고 써야하기 때문에 성능은 떨어지는 편
  - 위의 특징이 있을 뿐이지 원자적 연산을 지원하지 않아 동시성 환경에서 안전한 것은 아니다
  - 여러 스레드가 공유하기 때문에 해당스레드의 상태 플래그로 자주사용
     
  
- Atomic class
  - Lock-free 읽기
  - 원자적인 연산을 제공
  - 동시성을 지원하기 위해 내부에서 많은 오버헤드 발생여지 있다
  - 원리
    - 하드웨어의 CAS(Compare-And-Swap)명령어 사용 및 갱신
    - 메모리베리어 (cpu의 재배치 방지 -> 메모리 일관성 제어 )
    - 락  

  
reference : [자바에서 동시성 문제를 해결하는 3가지 키워드](https://devwithpug.github.io/java/java-thread-safe/) 

