## 12장 정리 및 가상스레드

<br> 

#### 12장 간단 정리
<br>

> 자바는 다양한 운영체제별 스레드 모델의 차이를 숨기는 통합된 스레드 인터페이스를 제공한다
<br>

각 운영체제의 처리 방식이 다르더라도 커널스레드에 자바 스레드가 매핑되면서 운영체제를 몰라도

자바 스레드 모델이 동일하게 동작하도록 추상화되어 있어 일관된 방법으로 스레드를 사용할 수 있음을 알 수 있었다.
<br>

스레드 풀을 활용해 비용을 줄이는 방식으로 개선해 왔으나

하지만 

커널에서 사용할 수 있는 자바의 플랫폼스레드의 갯수는 제한적이고 (스케일 업어려움)

스위칭비용과 동기화과정에서 점유된 리소스가 블로킹되면서 

전체 시스템의 처리량이 감소하고 응답 시간이 증가함과 더불어 리소스 낭비를 피할 수 없었다.

###### 참고 ) Non-blocknig 방식의 Reactive Programming (컨텍스트 확인이 어려워 디버깅이..)(Exception도 스레드기반)

<br>

####  코루틴과 가상스레드
<br>

> 코루틴의 개념에 영향을 받은 가상스레드


|코루틴|가상 스레드|
|------|---|
|경량 스레드	|경량 스레드|
|협력적 스케줄링 (사용자 정의)|선점형 스케줄링 (JVM 스케줄러 관리)|
|자원소모 매우 적음 (스택X)|적음|
|비동기 I/O|대규모 동시성 처리, I/O 작업|
|Clouser 저장|stack 저장|

###### 컨텍스트 스위치 비용을 줄여 어플리케이션 레벨에서 JVM 자체적으로 내부 스케줄링, 더 많은 스레드를 생성해도 자원소모 적고 성능 유지 가능 

> 파이버 <br>
> 가상 스레드 초기 이름, 경량 스레드 개념을 도입할 때 사용<br>
> 초기 협력적 스레딩<br>
> 사용자 스레드<br>

<br><br>

####  기존 자바스레드와 가상스레드 메모리 사용 및 상태 저장 
<br>

- 기존 스레드(커널 스레드)의 저장 방식
  - 고유스택(커널 스레드)는 각각 고정된 영역을 할당받는다.
  - JVM에서 관리되는 추상화된 개념이며 실제 작업은 운영체제의 커널 스레드가 처리 
  - 커널 스레드에서 읽고 저장하면서 일어나는 컨텍스트 스위칭이 비용이 크다
  - 상태관리 시 os의 자원과 잘 분리되지않아 자원소모가 크다

- 가상스레드
  - 기존스레드와 다르게 경량화된 스택 사용
  - JVM 에서 이를 읽고 저장하는 비용이 상대적으로 적고 빠름
  - 하드웨어,운영체제 자원에 의존하지 않고 JVM 에서 관리되어 효율적인 메모리 사용 및 상태관리 가능

