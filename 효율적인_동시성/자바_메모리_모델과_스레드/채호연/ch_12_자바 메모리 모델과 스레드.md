# CH.12 자바 메모리 모델과 스레드

## 12.1 들어가며

#### 1. 현대 컴퓨팅 환경에서 _동시성 프로그래밍_ 의 중요성

- 서버의 주요 성능 지표 : **\*TPS**(Transaction Per Second, 초당 트랜잭션)\*
- 이 성능을 향상시키는 방법은 무엇이 있을까?
  - 다수의 스레드를 운용하여 동시에 여러 요청을 처리하기. (동시성 프로그래밍)
- 스레드는 많으면 많을 수록 좋을까?
  - a. 스레드가 적을 경우 -> 요청을 처리하기 위해 I/O 발생 시 병목 발생 가능성 높은 확률로 상승.
  - b. 스레드가 많을 경우 -> 한정된 자원(ex. DB Connection)을 두고 여러 개의 스레드가 경합 -> _스레드 교착 상태(Deadlock)_ 혹은 _특정 스레드의 강제 종료_ 발생

따라서 효율적인 서버 설계를 위해선 <u>동시성 및 동시성 프로그래밍</u> 이해 중요.

그렇다면 SW 레벨에서의 효율적 동시성 프로그래밍이란 무엇일까?
어떤 방식으로 이루어질까?

이를 파악하기 위해선 HW 레벨에서는 - 정확히는 멀티프로세서 환경에서 - 동시성이 어떻게 효율적으로 구현되고 있는지 살펴보는 것이 도움이 된다.

## 12.2 하드웨어에서의 효율과 일관성

### 12.2.1 물리 머신의 성능 결정 요인 : 대기시간

- 프로세서의 처리속도는 아주 빠르다.
- 이와 비교했을 때 주변 장치와의 I/O - ex. 메인 메모리 참조 - 의 시간 비용은 아주 큰 편.

  - L1 캐시 참조가 0.5ns, 주 메모리 참조는 100ns <small>(_2021, 가상 면접 사례로 배우는 대규모 시스템 설계 기초_)</small>

- 처리 속도 차이를 비롯한 다양한 요인으로부터 발생하는 대기 시간을 최소화하고 프로세서의 성능을 최대로 활용하기 위해 현대의 컴퓨터는 크게 두 가지 방법을 활용한다.
  - 1. **_캐시_** 계층 도입
  - 2. **\*비순차적 실행 최적화**(Out-of-order Execution Optimization)\*

### 12.2.2 프로세서 활용 효율 확보 방안 (1) : 캐시 계층 도입

> **_캐시_**
>
> - 미래에 발생 가능한 '자원에 대한 요청'에 빠르게 응답 가능하도록 이를 저장 및 보관하고 있는 _하드웨어/소프트웨어 요소_.

 <br>

<image src = "https://raw.githubusercontent.com/leonroars/photo_distributor/main/JVM_Study/ch_12/jvm_ch_12_1.png" width = 600px>

- 현대의 멀티프로세서는 프로세서 별 캐시를 별도로 보유하도록 설계하는 것이 보편적.'
- 당연하게도, 캐시 내에 존재하는 데이터는 메인 메모리 데이터를 복사해둔 것이기 때문에, 신뢰할 수 있는 연산 결과를 보장하기 위해선
  <u>캐시 내 데이터와 메모리 내 해당 데이터 간 일관성 유지가 필요</u>하다.
- 또한 현대의 _공유 메모리 멀티프로세서 시스템_ 에서는 **_캐시 일관성(Cache Coherence)_** 문제가 존재.
  - 복수의 캐시 간 데이터 일관성을 유지하는 것이 하나의 이슈로 부상한 것.

<br>

위의 이유들로 인해 캐시와 메모리 간 데이터 일관성을 보장하는 어떤 <u>규칙</u>이 필요한 것.
이 규칙(Protocol)이 바로 **_메모리 모델_**.

> **_메모리 모델_**
>
> - 공유 메모리 멀티프로세서 시스템에서, \
>   각 프로세서 별 캐시와 메인 메모리 간 데이터 일관성을 유지하기 위해 메모리 및 캐시 I/O시 반드시 준수하도록 만든 프로토콜.

### 12.2.3 프로세서 활용 효율 확보 방안 (2) : _비순차적 실행 최적화_

> **참고하면 재밌는 자료**
>
> 1. [BOJ 11399 : ATM](https://www.acmicpc.net/problem/11399)
> 2. [Programmers : 디스크 컨트롤러](https://school.programmers.co.kr/learn/courses/30/lessons/42627)

> **\*비순차적 실행 최적화**(Out-of-order Execution Optimization)\*
>
> - 프로그램에 작성된 명령어의 순서 그대로 처리하는 것보다 더 나은 처리 순서가 존재하는 경우, 더 빠른 순서로 명령어를 실행함으로써 전체 프로그램 시행 속도를 최적화하는 방법.
> - 프로그램에 명시된 절차대로 처리했을 때와 명령어 처리 결과가 같도록 보장하는 방안이 필요.
> - 프로세서 차원에서의 이야기.(물리머신에서 발생하는 일이라는 것.)
>   > - 가상 머신에서도 이로부터 아이디어를 차용하여 유사한 방식으로 프로그램 실행 최적화를 하기도 한다. (JVM JIT 컴파일러의 _명령어 재정렬_)

- 우리가 작성하는 프로그램 = 명령어의 집합
- 절차지향적 언어에서는 프로그램에 작성된 명령어의 순서 그대로 처리된다.
- 이때 만약 대기 시간이 많이 요구되는 명령들이 곳곳에 산재해있다면 -> 프로그램 전체 처리 속도 저하.
- 이러한 경우 <u>멱등성을 보장하는 방안이 마련된다는 전제 하에</u>, 대기시간이 많이 요구되는 것들보다 다른 작업을 빨리 처리하는 것이 더 효율적일 수 있다.

## 12.3 자바 메모리 모델(_JMM, Java Memory Model_)

### 12.3.0 _자바 메모리 모델_(_JMM_)이란?

- <u>Java 의 스레드가 메모리와 상호작용하는 _방식_ 혹은 _규칙_</u> 을 정의한 **명세**
- 스레드가 활용하는 캐시 성격의 메모리와 JVM이 관리하는 메모리를 <u>개념적</u>으로 **작업 메모리**와 **메인 메모리**로 구분함.
- 즉 *작업 메모리*와 *메인 메모리*는 '스레드로부터의 직접 접근 가능성' 및 스레드와 관련지었을 때 그 역할에 따라 개념적으로 구분한 것.

> **JVM의 메모리 구조 정의에 관한 혼동 정리** > <br>
>
> **1. 실제 구현 상 JVM 메모리 구조**
>
> > <image src = "https://raw.githubusercontent.com/leonroars/photo_distributor/main/JVM_Study/ch_12/jvm_ch_12_3.png" width = 600px>
>
> - Method Area : 정적 변수(Static Variables, Class Variable), 프로그램 내 정의된 Method의 Bytecode 등 ...
> - Heap Area : 생성된 인스턴스가 저장되는 영역. Java 프로그램에 의해 직접 접근은 허용되지 않는다.
> - Stack Area : 지역변수, Heap 영역에 존재하는 인스턴스에 대한 참조변수가 저장되는 영역.
> - PC Register : 현재 실행 중인 JVM 명령어의 주소가 저장되는 곳. Bytecode가 ISA(Instruction Set Architecture) 형태의 명령어로 저장되어있음. JVM이 이를 CPU에 전달하여 실행하는 방식.
> - Native Method Stack : 자바 이외의 언어(C/C++)로 작성된 메서드 코드와 해당 메서드의 매개/지역 변수가 저장되는 영역.
>   <br> > <br>
>
> **2. JMM 명세 상 메모리 구분**
>
> - 메인 메모리 : 스레드가 공유하는 하나의 공용 메모리 공간.
> - 작업 메모리 : 스레드 별로 생성 및 할당되는 스레드 전용 저장 공간.

### 12.3.1 JMM 명세에서의 '메인 메모리' & '작업 메모리'

<image src = "https://raw.githubusercontent.com/leonroars/photo_distributor/main/JVM_Study/ch_12/jvm_ch_12_2.png" width = 600px>

### 12.3.2 메모리 간 상호작용 : 메인 메모리와 작업 메모리간 작업 프로토콜

#### 1. 각 메모리의 역할

1. 메인 메모리

- 물리 머신에서의 주기억장치와 대응.
- 스레드에서의 직접 읽기/쓰기 불가.

2. 작업 메모리

- 물리 머신에서의 캐시/레지스터와 대응.

#### 2. JMM 명세 상 메인 메모리와 작업 메모리간의 상호 작용 : 엄근진한 프로토콜

메인 메모리와 작업 메모리 간의 상호작용 규칙 그 자체인 JMM은 크게 <u>두 가지 원칙</u>에 의거한다.

- **일관성** : JMM은 스레드가 참조하는 작업 메모리와 메인 메모리 간 데이터 일관성을 유지할 수 있도록 규칙을 정의한 것.
- **원자성** : 이러한 일관성 유지의 방안으로, 메모리 관련 I/O 작업을 크게 8가지로 세분화하여 각 작업이 원자성을 갖도록 정의한 것.

##### 메모리 I/O 작업 8가지 분류

1. _잠금(lock)_ : 메인 메모리에 존재하는 변수를 특정 스레드만 사용 가능한 상태로 만드는 작업(연산)
   - 특정 변수에 대한 잠금은 하나의 스레드만 가능하다. 즉, 다른 스레드가 잠금 연산을 시행한 변수를 다른 스레드가 다시 잠글 수 없다는 것.
   - 변수에 대한 잠금 연산은 여러 번 시행 가능. 단, 잠금 해제 연산 또한 잠금 연산 시행 횟수만큼 필요.
   - 변수를 잠글 시, 다른 스레드의 작업 메모리 내 해당 변수의 값이 지워진다. 이후 잠금이 해제되어 다른 스레드에서 사용하려 할 경우에는 적재 / 할당 작업 재수행하여 변수 초기화 필요.
2. _잠금 해제(unlock)_ : 메인 메모리에 존재하는 변수의 잠금 상태를 해제하는 연산
   - 잠근 연산을 시행한 스레드만 시행 가능.
   - 잠금 해제 시, 해당 변수를 메인 메모리로 동기화(_저장_ 및 _쓰기_ 연산) 반드시 선행되어야 한다.
     - 어떤 스레드에서 독점적으로 사용했다 -> 변동 가능성이 있다.
     - 따라서 잠금 해제를 통해 다른 스레드가 해당 변수를 참조하고 연산에 활용하도록 하기 이전에 독점 했던 스레드에서 발생했을 지도 모를 변동 사항을 메인 메모리에도 전달하여 동기화하는 것이 당연히 필요함.
3. _읽기(read)_
   - 메인 메모리의 목표 변수값을 읽고 사용하고자 한 <u>스레드의 작업 메모리로 전송</u>
   - 이후 시행될 _적재_ 연산을 위한 전초작업.
4. _적재(load)_
   - 전송 받은 변숫값을 작업 메모리 내 해당 변수에 복사해넣는 연산.
5. _사용(use)_
   - 작업 메모리의 변숫값을 실행 엔진으로 전달.
   - 해당 변숫값을 사용하는 바이트코드 명령어를 JVM이 만날 때마다 이 연산이 실행된다.
6. _할당(assign)_
   - 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당.
   - ex. 프로그램 상 사용자 입력 혹은 프로그램에 정의된 연산 시행 결과가 어떤 변수에 할당되는 과정을 생각하면 이해하기 쉽다!
   - 할당 연산이 시행된 변수는 반드시 메인 메모리로 동기화 되어야한다.
7. _저장(store)_
   - 작업 메모리의 변숫값을 메인 메모리로 전송.
   - 이후 이어질 _쓰기_ 연산을 위한 전초작업.
8. _쓰기(write)_
   - 저장 연산을 통해 작업 메모리로부터 전송된 변숫값을 메인 메모리의 해당 변수에 기록.

이러한 여덟 가지 연산에 대해서 JMM은 다음과 같은 규칙 또한 정의하고 있다.

- 변수는 메인 메모리에서만 새로 생겨날 수 있다. -> 당연하다. 작업 메모리는 메인 메모리의 반영(Reflection)이기 때문.
- 작업 메모리 내 초기화되지 않은 변수 - 적재 및 할당이 이루어지지 않은 변수 - 를 사용할 수 없다.

### 12.3.3 volatile 변수용 특별 규칙

##### `volatile`

- **정의** : _가시성 보장_ 받는 변수로 선언하는 키워드.
  - 이때 *가시성 보장*이란, 모든 스레드에서 해당 변수의 값을 볼 수 있다는 의미.
- **특성**

  1.  _가시성 보장_
      - 일반 변수의 경우, 어떤 스레드에서 특정 변수의 값이 변경될 경우 write-back 과정을 통해 메인 메모리와 동기화를 함으로써 다른 스레드에서도 변경된 값을 볼 수 있음.
      - `volatile` 변수의 경우, 변경 즉시 다른 스레드에서도 변경된 값을 확인 가능.
  2.  해당 변수에 대한 _명령어 재정렬 최적화 방지_ - bytecode 생성 시 메모리 장벽 역할을 수행하는 명령어를 함께 생성하여 추가. (ex. `addl $0x0, (%esp)`)
      > _메모리 장벽_
      >
      > - 명령어 재정렬 최적화 수행 시, 장벽 뒤의 명령어가 장벽 앞으로 재정렬될 수 없도록 막는 역할을 하는 **명령어** 혹은 연산적 장치.

- **사용 시 주의 사항**

  - `volatile` 키워드는 <u>가시성만 보장</u> 한다.
    - 즉, `volatile` 키워드로 선언된 변수에 대한 연산의 원자성이 보장되지 않는 경우엔 해당 키워드로 선언된 변수의 일관성이 깨질 수 있다는 것.
    - `volatile` 키워드 변수값의 일관성이 보장되는 연산 시나리오 두 가지
      - 연산 결과가 `volatile` 키워드로 선언된 변수와 무관. 혹은 해당 변수에 대한 수정 연산 시행 스레드가 하나임이 보장됨.
      - 해당 변수에 대한 연산이 다른 상태 변수의 불변성 제약 조건 관여하지 않는 경우.

- JMM이 규정하는 `volatile` 변수용 특별 규칙
  - 해당 규칙을 준수하여 JVM의 메모리가 설계되었기 때문에 위에서 다룬 `volatile` 의 성질이 지켜지는 것.
  1.  스레드 T가 `volatile` 변수 V를 사용하려면 T가 V에 행한 이전 연산이 적재여야 한다. \
      또한, T가 V를 적재하기 위해선 그 이전에 수행한 마지막 연산이 사용이어야 한다.
      - 즉, 작업 메모리에서 변수 V가 사용될 때마다 메인 메모리로부터 해당 변수 값을 최신 상태로 갱신을 강제하는 것.
      - 이렇게 함으로서 `volatile` 의 성질 구현.
  2.  스레드 T가 변수 V를 저장하려면 T가 V에 수행한 이전 연산이 할당이어야 한다. \
      또한, T가 V를 할당하려면 이전에 마지막으로 수행한 연산이 저장이어야 한다.
      - 즉, 작업 메모리에서 V에 대한 수정 발생 시, 이를 즉각 메인 메모리로 동기화함으로써 다른 스레드에서 V를 참조할 때의 일관성을 보장하는 것.

> **`volatile` 타입 변수의 가시성이 보장되는 원리: `lock` 접두어와 메모리 장벽**
>
> - JIT 컴파일러는 `volatile` 변수에 대한 **쓰기 연산**을 컴파일할 때 `lock` 접두어로 시작하는 명령어를 생성한다.
>
>   > - 이때 `lock` 접두어가 붙은 명령어로 인한 쓰기 연산은 _캐시 일관성 프로토콜_ 에 의해 다른 스레드의 작업 메모리(캐시)에 저장된 해당 변수의 값을 _invalid_ 로 변경한다. (책에서 언급된 `다른 프로세서(또는 코어)가 자신의 캐시를 무효화하게 한다`에 해당하며, 이 무효화는 Invalidate를 의미한다.)
>   > - 따라서 다른 스레드는 해당 변수를 읽을 때, 항상 최신의 값을 가져오게 됨으로써 가시성이 보장되는 것이다.
>
> - 또한, `addl $0x0, (%esp)`는 _no-op_ 명령어이지만, `lock` 접두어와 함께 사용될 경우 **메모리 장벽**으로 동작한다.
>   > - 이 명령어는 메모리 연산의 재정렬을 방지하여 `volatile` 변수의 읽기 및 쓰기 연산이 의도한 순서대로 수행되도록 보장한다.

### 12.3.4 `long` 과 `double` 변수용 특별 규칙 : 연산의 원자성에 관한 느슨한 규칙

- JMM에선 잠금 및 잠금 해제, 읽기, 적재, 할당, 사용, 저장, 쓰기 연산에 대해 원자적임을 요구.
- 하지만 64비트 데이터 타입인 `long`, `double` 타입 데이터에 대해, <u>non-volatile 일 경우</u> 32 비트 데이터 두 개로 쪼개어 원래의 연산을 시행할 수 있도록 함.

> **왜 이렇게 나누어 처리가 가능하도록 했을까?**
>
> - 32 비트 아키텍처 시절엔 64비트 데이터를 한 단위로 처리할 수 없었기 때문.

#### 이러한 비원자적 연산 허용의 부작용은 없을까?

- 실험 결과 64비트 아키텍처에서는 문제 없었음.
- 다만, 32비트 아키텍처에서는,
  - `long` : 해당 변수 변동 사항의 '절반'만 보게 되는 경우가 발생.
  - `double` : 현대의 CPU는 부동 소수점 처리 유닛이 별도로 존재하기 때문에 이 경우 발생 X.

#### 부작용 방지 대책 : `-XX:+AlwaysAtomicAccesses` 실행 매개 변수.

- 이러한 부작용을 방지 하기 위해 JDK 9부터는 `-XX:+AlwaysAtomicAccesses` 실행 매개변수 도입
  - 모든 데이터 타입에 대해 연산 원자성을 강제하는 것.

#### 결론

- 64비트 데이터 타입 변수의 경우, 해당 변수를 놓고 스레드 간 경합이 발생할 가능성이 없다고 판단될 경우 `volatile` 선언 불필요.

### 12.3.5 원자성, 가시성, 실행 순서

- _JMM_ : 동시성 프로그래밍 환경에서 **_원자성_**, **_가시성_**, **_실행순서를_** 어떻게 처리하는지를 명세한 것.

#### 원자성(Atomicity)

> 어떤 연산 혹은 연산 집합이 원자적으로 처리될 것을 보장하는 성질.

1. 변수 연산

   - JMM은 다음의 변수 연산에 대해 원자성을 보장.
     - 읽기
     - 쓰기
     - 적재
     - 할당
     - 사용
     - 저장
   - 64 비트 데이터의 경우에도 대부분의 상황에서 원자성을 보장한다. (_12.3.4 long, double 변수용 특별 규칙_ 참고)

2. 애플리케이션 수준에서의 원자성 보장 : `synchronized` 키워드를 통한 잠금 및 잠금 해제 연산 제공
   - 사용자가 직접 잠금 및 잠금 해제 연산을 사용하도록 제공 X -> `synchronized` 키워드 통해 제공.
   - `synchronized` : 해당 키워드 선언된 block 혹은 method에 대해 monitor lock/unlock 실시
     - Bytecode 컴파일 결과 상 `monitorenter`와 `monitorexit` 두 가지 명령어로 시작과 끝이 명시되어 있다.

#### 가시성

- 가시성 : 공유 변수의 수정 결과가 다른 스레드로부터 인지가능함을 의미.
- Java에서의 가시성은 다음과 같은 세 가지 키워드를 통해 보장된다.
  - `volatile`
  - `synchronized` : _잠금 해제 전 블럭 혹은 메서드 내 변수값을 다시 메모리에 동기화(읽기 및 쓰기)_ 할 것을 강제함으로써 가시성 보장.
  - `final` : 객체 생성 당시 해당 변수 초기화 강제 -> 객체 생성 시점에서 다른 스레드는 당연히 초기화가 완료된 필드를 볼 수 있게 된다.

#### 실행 순서

- 자바 프로그램에서의 실행 순서 : _스레드 안에서는 순차적인 시맨틱(Within-thread as-if-serial Semantics)_
- Java가 실행 순서를 보장하는 방법 : `volatile`, `synchronized` 키워드 제공
  - `volatile` : 컴파일 시 메모리 장벽 역할을 수행하는 명령어를 삽입함으로써 실행 순서 보장.
    - 해당 키워드 컴파일 시 `lock` 접두어를 가진 `no-op` 명령어(메모리 장벽 역할 수행)를 삽입함으로써 명령어 재정렬로부터 해당 변수에 대한 연산의 실행 순서를 보호한다.
  - `synchronized` : `락을 소유한 단 하나의 스레드만 접근 가능하다` 라는 accessibility 규칙을 강제함으로써 보장.
    - 즉 접근 권한 통제를 통해 실행 순서를 보장하는 것.

> **_스레드 안에서는 순차적인 시맨틱(Within-thread as-if-serial Semantics)_**
>
> ```
> 현재 스레드에서 보면 모든 연산이 순서대로 수행된다.
> 하지만 다른 스레드에서 보면 순서가 다를 수 있다.
> ```
>
> 1. `현재 스레드에서 보면 모든 연산이 순서대로 수행된다.`
>    > - 이는 현재 실행 중인 스레드 내에서는 해당 스레드 내 명령어 및 변수에 대한 접근 및 사용이 순차적으로 이루어지는 것으로 보이나,
> 2. `하지만 다른 스레드에서 보면 순서가 다를 수 있다.`
>    > - 실제로는 결과적으로만 그렇게 보일 뿐(그것도 그 스레드 내에서만) 실제로는 명령어 재정렬이 발생하여 공유 자원에 대한 연산 순서가 작성자가 생각한 순서와 다르게 실행될 수 있으며, 그렇기 때문에 다른 스레드에서 보면 순서가 다를 수 있다는 의미이다.

### 12.3.6 선발생 원칙(Happens-Before Order or Happend-Before Relationship)

#### 1. 정의

- **_선발생_** : 어떤 작업이 다른 작업보다 먼저 실행되는 것을 뜻한다.
- **_선발생 규칙_** : 선발생 조건을 정의한 규칙. 해당 규칙을 따를 시 어떤 작업이 다른 작업보다 먼저 실행된다.

#### 2. 선발생 규칙 : 목록

- _프로그램 순서 규칙_ : 한 스레드 내에서 작업 순서는 _제어 흐름 순서_ 에 근거한다.
- _모니터 락 규칙_ : 잠금 해제 연산은 같은 락에 대한 잠금 연산보다 '시간 상' 먼저 실행된다.
- _휘발성 변수 규칙_ : `volatile` 변수에 대한 쓰기 연산은 해당 변수에 대한 읽기 연산보다 '시간 상' 먼저 실행된다.
- _스레드 시작 규칙_ : Thread 객체의 start() 메서드는 해당 스레드의 어떤 작업 보다 먼저 실행된다.
- _스레드 종료 규칙_ : 스레드의 모든 작업은 해당 스레드의 종료 감지보다 먼저 발생한다.
- _스레드 인터럽트 규칙_ : Thread의 interrupt() 메서드 호출은 interrupt 되는 스레드의 interrupt 감지보다 먼저 실행된다.
  - 예를 들어 스레드 A에서 스레드 B에 대해 `Thread.interrupt()` 를 호출했다고 하자.
  - 이 호출은 스레드 B가 다음의 두 가지 방식을 통해 자신을 향한 interrupt 발생을 인지하기 전에 발생해야 한다는 것.
    - 1. `Thread.interrupted()` 결과 true 인 경우.
    - 2. 해당 스레드 `sleep()`, `wait()`, `join()` 중에 `InterruptedException` 발생한 경우.
- _종료자 규칙_ : 객체 초기화(생성자 실행 완료)는 `finalize()` 메서드 시작보다 먼저 발생한다.
- _전이성(Transitive)_ : 연산 A가 B보다 선발생하고 B가 C보다 선발생한다면, A는 C보다 선발생한다.

## 12.4 자바와 스레드

## 12.5 자바와 가상 스레드
