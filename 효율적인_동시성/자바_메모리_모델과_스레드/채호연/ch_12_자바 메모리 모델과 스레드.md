# CH.12 자바 메모리 모델과 스레드


## 12.1 들어가며

#### 1. 현대 컴퓨팅 환경에서 *동시성 프로그래밍* 의 중요성
- 서버의 주요 성능 지표 : ***TPS**(Transaction Per Second, 초당 트랜잭션)*
- 이 성능을 향상시키는 방법은 무엇이 있을까?
  - 다수의 스레드를 운용하여 동시에 여러 요청을 처리하기. (동시성 프로그래밍)
- 스레드는 많으면 많을 수록 좋을까? 
  - a. 스레드가 적을 경우 -> 요청을 처리하기 위해 I/O 발생 시 병목 발생 가능성 높은 확률로 상승.
  - b. 스레드가 많을 경우 -> 한정된 자원(ex. DB Connection)을 두고 여러 개의 스레드가 경합 -> *스레드 교착 상태(Deadlock)* 혹은 *특정 스레드의 강제 종료* 발생

따라서 효율적인 서버 설계를 위해선 <u>동시성 및 동시성 프로그래밍</u> 이해 중요.

그렇다면 SW 레벨에서의 효율적 동시성 프로그래밍이란 무엇일까?
어떤 방식으로 이루어질까?

이를 파악하기 위해선 HW 레벨에서는 - 정확히는 멀티프로세서 환경에서 - 동시성이 어떻게 효율적으로 구현되고 있는지 살펴보는 것이 도움이 된다.

## 12.2 하드웨어에서의 효율과 일관성

### 12.2.1 물리 머신의 성능 결정 요인 : 대기시간
- 프로세서의 처리속도는 아주 빠르다.
- 이와 비교했을 때 주변 장치와의 I/O - ex. 메인 메모리 참조 - 의 시간 비용은 아주 큰 편.
  - L1 캐시 참조가 0.5ns, 주 메모리 참조는 100ns <small>(*2021, 가상 면접 사례로 배우는 대규모 시스템 설계 기초*)</small>

- 처리 속도 차이를 비롯한 다양한 요인으로부터 발생하는 대기 시간을 최소화하고 프로세서의 성능을 최대로 활용하기 위해 현대의 컴퓨터는 크게 두 가지 방법을 활용한다.
  - 1) ***캐시*** 계층 도입
  - 2) ***비순차적 실행 최적화**(Out-of-order Execution Optimization)*

### 12.2.2 프로세서 활용 효율 확보 방안 (1) : 캐시 계층 도입

> ***캐시***
> - 미래에 발생 가능한 '자원에 대한 요청'에 빠르게 응답 가능하도록 이를 저장 및 보관하고 있는 *하드웨어/소프트웨어 요소*.

 <br> 

<image src = "https://raw.githubusercontent.com/leonroars/photo_distributor/main/JVM_Study/ch_12/jvm_ch_12_1.png" width = 600px>

- 현대의 멀티프로세서는 프로세서 별 캐시를 별도로 보유하도록 설계하는 것이 보편적.'
- 당연하게도, 캐시 내에 존재하는 데이터는 메인 메모리 데이터를 복사해둔 것이기 때문에, 신뢰할 수 있는 연산 결과를 보장하기 위해선
  <u>캐시 내 데이터와 메모리 내 해당 데이터 간 일관성 유지가 필요</u>하다.
- 또한 현대의 *공유 메모리 멀티프로세서 시스템* 에서는 ***캐시 일관성(Cache Coherence)*** 문제가 존재.
  - 복수의 캐시 간 데이터 일관성을 유지하는 것이 하나의 이슈로 부상한 것.

<br>

위의 이유들로 인해 캐시와 메모리 간 데이터 일관성을 보장하는 어떤 <u>규칙</u>이 필요한 것.
이 규칙(Protocol)이 바로 ***메모리 모델***.


> ***메모리 모델***
> - 공유 메모리 멀티프로세서 시스템에서, \
>   각 프로세서 별 캐시와 메인 메모리 간 데이터 일관성을 유지하기 위해 메모리 및 캐시 I/O시 반드시 준수하도록 만든 프로토콜.


### 12.2.3 프로세서 활용 효율 확보 방안 (2) : *비순차적 실행 최적화*

> **참고하면 재밌는 자료**
> 1) [BOJ 11399 : ATM](https://www.acmicpc.net/problem/11399)
> 2) [Programmers : 디스크 컨트롤러](https://school.programmers.co.kr/learn/courses/30/lessons/42627)

> ***비순차적 실행 최적화**(Out-of-order Execution Optimization)*
> - 프로그램에 작성된 명령어의 순서 그대로 처리하는 것보다 더 나은 처리 순서가 존재하는 경우, 더 빠른 순서로 명령어를 실행함으로써 전체 프로그램 시행 속도를 최적화하는 방법.
> - 프로그램에 명시된 절차대로 처리했을 때와 명령어 처리 결과가 같도록 보장하는 방안이 필요.
> - 프로세서 차원에서의 이야기.(물리머신에서 발생하는 일이라는 것.) 
>> - 가상 머신에서도 이로부터 아이디어를 차용하여 유사한 방식으로 프로그램 실행 최적화를 하기도 한다. (JVM JIT 컴파일러의 *명령어 재정렬*)

- 우리가 작성하는 프로그램 = 명령어의 집합
- 절차지향적 언어에서는 프로그램에 작성된 명령어의 순서 그대로 처리된다.
- 이때 만약 대기 시간이 많이 요구되는 명령들이 곳곳에 산재해있다면 -> 프로그램 전체 처리 속도 저하.
- 이러한 경우 <u>멱등성을 보장하는 방안이 마련된다는 전제 하에</u>, 대기시간이 많이 요구되는 것들보다 다른 작업을 빨리 처리하는 것이 더 효율적일 수 있다.

## 12.3 자바 메모리 모델(*JMM, Java Memory Model*)

### 12.3.0 *자바 메모리 모델*(*JMM*)이란?
- <u>Java 의 스레드가 메모리와 상호작용하는 *방식* 혹은 *규칙*</u> 을 정의한 **명세**
- 스레드가 활용하는 캐시 성격의 메모리와 JVM이 관리하는 메모리를 <u>개념적</u>으로 **작업 메모리**와 **메인 메모리**로 구분함.
- 즉 *작업 메모리*와 *메인 메모리*는 '스레드로부터의 직접 접근 가능성' 및 스레드와 관련지었을 때 그 역할에 따라 개념적으로 구분한 것.


> **JVM의 메모리 구조 정의에 관한 혼동 정리**
> <br>
> 
> **1. 실제 구현 상 JVM 메모리 구조**
>> <image src = "https://raw.githubusercontent.com/leonroars/photo_distributor/main/JVM_Study/ch_12/jvm_ch_12_3.png" width = 600px>
> - Method Area : 정적 변수(Static Variables, Class Variable), 프로그램 내 정의된 Method의 Bytecode 등 ...
> - Heap Area : 생성된 인스턴스가 저장되는 영역. Java 프로그램에 의해 직접 접근은 허용되지 않는다.
> - Stack Area : 지역변수, Heap 영역에 존재하는 인스턴스에 대한 참조변수가 저장되는 영역.
> - PC Register : 현재 실행 중인 JVM 명령어의 주소가 저장되는 곳. Bytecode가 ISA(Instruction Set Architecture) 형태의 명령어로 저장되어있음. JVM이 이를 CPU에 전달하여 실행하는 방식.
> - Native Method Stack : 자바 이외의 언어(C/C++)로 작성된 메서드 코드와 해당 메서드의 매개/지역 변수가 저장되는 영역.
> <br>
> <br>
> 
> **2. JMM 명세 상 메모리 구분**
> - 메인 메모리 : 스레드가 공유하는 하나의 공용 메모리 공간.
> - 작업 메모리 : 스레드 별로 생성 및 할당되는 스레드 전용 저장 공간. 

### 12.3.1 JMM 명세에서의 '메인 메모리' & '작업 메모리'
<image src = "https://raw.githubusercontent.com/leonroars/photo_distributor/main/JVM_Study/ch_12/jvm_ch_12_2.png" width = 600px> 


### 12.3.2 메모리 간 상호작용 : 메인 메모리와 작업 메모리간 작업 프로토콜

#### 1. 각 메모리의 역할
1) 메인 메모리
 - 물리 머신에서의 주기억장치와 대응.
 - 스레드에서의 직접 읽기/쓰기 불가.
2) 작업 메모리
 - 물리 머신에서의 캐시/레지스터와 대응.

#### 2. JMM 명세 상 메인 메모리와 작업 메모리간의 상호 작용 : 엄근진한 프로토콜

메인 메모리와 작업 메모리 간의 상호작용 규칙 그 자체인 JMM은 크게 <u>두 가지 원칙</u>에 의거한다.
- **일관성** : JMM은 스레드가 참조하는 작업 메모리와 메인 메모리 간 데이터 일관성을 유지할 수 있도록 규칙을 정의한 것.
- **원자성** : 이러한 일관성 유지의 방안으로, 메모리 관련 I/O 작업을 크게 8가지로 세분화하여 각 작업이 원자성을 갖도록 정의한 것.

##### 메모리 I/O 작업 8가지 분류
1) *잠금(lock)* : 메인 메모리에 존재하는 변수를 특정 스레드만 사용 가능한 상태로 만드는 작업(연산)
   - 특정 변수에 대한 잠금은 하나의 스레드만 가능하다. 즉, 다른 스레드가 잠금 연산을 시행한 변수를 다른 스레드가 다시 잠글 수 없다는 것.
   - 변수에 대한 잠금 연산은 여러 번 시행 가능. 단, 잠금 해제 연산 또한 잠금 연산 시행 횟수만큼 필요.
   - 변수를 잠글 시, 다른 스레드의 작업 메모리 내 해당 변수의 값이 지워진다. 이후 잠금이 해제되어 다른 스레드에서 사용하려 할 경우에는 적재 / 할당 작업 재수행하여 변수 초기화 필요.
2) *잠금 해제(unlock)* : 메인 메모리에 존재하는 변수의 잠금 상태를 해제하는 연산
   - 잠근 연산을 시행한 스레드만 시행 가능.
   - 잠금 해제 시, 해당 변수를 메인 메모리로 동기화(*저장* 및 *쓰기* 연산) 반드시 선행되어야 한다.
     - 어떤 스레드에서 독점적으로 사용했다 -> 변동 가능성이 있다. 
     - 따라서 잠금 해제를 통해 다른 스레드가 해당 변수를 참조하고 연산에 활용하도록 하기 이전에 독점 했던 스레드에서 발생했을 지도 모를 변동 사항을 메인 메모리에도 전달하여 동기화하는 것이 당연히 필요함.
3) *읽기(read)*
   - 메인 메모리의 목표 변수값을 읽고 사용하고자 한 <u>스레드의 작업 메모리로 전송</u>
   - 이후 시행될 *적재* 연산을 위한 전초작업.
4) *적재(load)*
   - 전송 받은 변숫값을 작업 메모리 내 해당 변수에 복사해넣는 연산.
5) *사용(use)*
   - 작업 메모리의 변숫값을 실행 엔진으로 전달.
   - 해당 변숫값을 사용하는 바이트코드 명령어를 JVM이 만날 때마다 이 연산이 실행된다.
6) *할당(assign)*
   - 실행 엔진에서 받은 값을 작업 메모리의 변수에 할당.
   - ex. 프로그램 상 사용자 입력 혹은 프로그램에 정의된 연산 시행 결과가 어떤 변수에 할당되는 과정을 생각하면 이해하기 쉽다!
   - 할당 연산이 시행된 변수는 반드시 메인 메모리로 동기화 되어야한다.
7) *저장(store)*
   - 작업 메모리의 변숫값을 메인 메모리로 전송.
   - 이후 이어질 *쓰기* 연산을 위한 전초작업.
8) *쓰기(write)*
   - 저장 연산을 통해 작업 메모리로부터 전송된 변숫값을 메인 메모리의 해당 변수에 기록.

이러한 여덟 가지 연산에 대해서 JMM은 다음과 같은 규칙 또한 정의하고 있다.
   - 변수는 메인 메모리에서만 새로 생겨날 수 있다. -> 당연하다. 작업 메모리는 메인 메모리의 반영(Reflection)이기 때문.
   - 작업 메모리 내 초기화되지 않은 변수 - 적재 및 할당이 이루어지지 않은 변수 - 를 사용할 수 없다.


### 12.3.3 volatile 변수용 특별 규칙

##### `volatile` 
- **정의** : *가시성 보장* 받는 변수로 선언하는 키워드.
  - 이때 *가시성 보장*이란, 모든 스레드에서 해당 변수의 값을 볼 수 있다는 의미.
- **특성**
   1) *가시성 보장*
      - 일반 변수의 경우, 어떤 스레드에서 특정 변수의 값이 변경될 경우 write-back 과정을 통해 메인 메모리와 동기화를 함으로써 다른 스레드에서도 변경된 값을 볼 수 있음.
      - `volatile` 변수의 경우, 변경 즉시 다른 스레드에서도 변경된 값을 확인 가능.
  1) 해당 변수에 대한 *명령어 재정렬 최적화 방지*
      - bytecode 생성 시 메모리 장벽 역할을 수행하는 명령어를 함께 생성하여 추가. (ex. `addl $0x0, (%esp)`)
> *메모리 장벽*
> - 명령어 재정렬 최적화 수행 시, 장벽 뒤의 명령어가 장벽 앞으로 재정렬될 수 없도록 막는 역할을 하는 **명령어** 혹은 연산적 장치.

- **사용 시 주의 사항**
  - `volatile` 키워드는 <u>가시성만 보장</u> 한다.
    - 즉, `volatile` 키워드로 선언된 변수에 대한 연산의 원자성이 보장되지 않는 경우엔 해당 키워드로 선언된 변수의 일관성이 깨질 수 있다는 것.
    - `volatile` 키워드 변수값의 일관성이 보장되는 연산 시나리오 두 가지
      - 연산 결과가 `volatile` 키워드로 선언된 변수와 무관. 혹은 해당 변수에 대한 수정 연산 시행 스레드가 하나임이 보장됨.
      - 해당 변수에 대한 연산이 다른 상태 변수의 불변성 제약 조건 관여하지 않는 경우.

- JMM이 규정하는 `volatile` 변수용 특별 규칙
  - 해당 규칙을 준수하여 JVM의 메모리가 설계되었기 때문에 위에서 다룬 `volatile` 의 성질이 지켜지는 것.
   1) 스레드 T가 `volatile` 변수 V를 사용하려면 T가 V에 행한 이전 연산이 적재여야 한다. \
      또한, T가 V를 적재하기 위해선 그 이전에 수행한 마지막 연산이 사용이어야 한다.
      -  즉, 작업 메모리에서 변수 V가 사용될 때마다 메인 메모리로부터 해당 변수 값을 최신 상태로 갱신을 강제하는 것.
      -  이렇게 함으로서 `volatile` 의 성질 구현.
   2) 스레드 T가 변수 V를 저장하려면 T가 V에 수행한 이전 연산이 할당이어야 한다. \
      또한, T가 V를 할당하려면 이전에 마지막으로 수행한 연산이 저장이어야 한다.
      - 즉, 작업 메모리에서 V에 대한 수정 발생 시, 이를 즉각 메인 메모리로 동기화함으로써 다른 스레드에서 V를 참조할 때의 일관성을 보장하는 것.


## 12.4 자바와 스레드

## 12.5 자바와 가상 스레드