# 12.1

## 동시성(Concurrency)

![image](https://github.com/user-attachments/assets/d52751e8-de3b-44e7-979b-c38908627d0d)

복수의 작업이 **동시에 실행되는 것처럼** 보이게 하는 것. 절대 동시에 실행되는 것이 아니다.<br />
빠르게 번갈아가며 실행되는, 이른바 **컨텍스트 스위칭**을 바탕으로 동작한다.<br />
실제로, 물리적으로 동시에 동작하는 개념은 **병렬성**이다.

### 1. 병렬성과의 비교

| **구분**            | **동시성 (Concurrency)**                                                                                   | **병렬성 (Parallelism)**                                                                                   |
|---------------------|----------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------------------------|
| **정의**            | 복수의 작업이 **동시에 실행되는 것처럼** 보이게 만드는 개념.                                                  | 복수의 작업이 **물리적으로 동시에 실행**되는 개념.                                                          |
| **실행 방식**        | 빠르게 번갈아가며 실행되는 **컨텍스트 스위칭**을 통해 구현.                                                    | 작업을 여러 코어 또는 프로세서에서 **동시에 실행**.                                                         |
| **중점**            | 작업 간 **조율** 및 자원의 효율적 사용.                                                                      | 작업을 분할하고 **병렬로 실행**하여 성능 극대화.                                                             |
| **실제 실행 여부**   | 실제로 동시에 실행되지 않음.                                                                                 | 실제로 동시에 실행됨.                                                                                       |


### 2. 동시성의 의의

동시에 실행되는 것처럼 보인다는 성격 때문에 자꾸 드는 생각

> 그냥 병렬성 개념만을 채택하면 안 되는가?

대답은 **No**<br />
**동시성과 병렬성은 따로 노는 개념이 아닌, 상호보완적인 개념**이다.

#### (1) 컴퓨팅 리소스는 유한하다.

작업의 병렬 처리는 **멀티코어**가 필수다. 즉, 단일 코어 CPU에서는 병렬 처리가 불가능하다.<br />
웬만한 비동기 처리는 굳이 병렬성까지 가지 않아도 동시성으로도 충분히 커버할 수 있다.<br />
버튼을 누르면 백그라운드에서의 파일 다운로드 과정을 생각해보자.

#### (2) 병렬 처리는 순서 고려가 없다.

작업 간의 순서 조율 및 의존 관계를 생각할 때는 동시성 개념을 채택해야 한다.<br />
대표적인 예시로는 **트랜잭션, I/O 작업**이 있다.

#### (3) 대기 시간을 최대한 활용한다.

세 명의 사람이 동시에 커피를 받으러 갔다고 가정하자. -> 병렬성<br />
그렇지만 커피 머신이 한 대라면 결국 대기 시간은 발생할 수밖에 없다.<br />
이 과정에서 기다리는 두 사람은 티스푼이나 시럽을 가지러 가는 것이 시간상 효율적이다. -> 동시성 

---

*참고*<br />
*https://oxylabs.io/blog/concurrency-vs-parallelism*<br />
*https://stackoverflow.com/questions/1050222/what-is-the-difference-between-concurrency-and-parallelism*

---

# 12.2

## 캐시 일관성 프로토콜

### 1. 캐시의 존재 의의

![image](https://github.com/user-attachments/assets/83b7ab2d-c05b-4b1c-9bee-e35b1e6f9c2a)

프로세서가 데이터를 읽고 작업 결과를 저장한 메모리에 접근해서 읽어오는 속도가 너무 느리다.<br />
그래서 프로세서와 메모리 사이에 캐시를 두고 좀 더 빠르게 원하는 데이터를 조회해오는 것이다.

### 2. 멀티 프로세서에서의 고려할 점

![image](https://github.com/user-attachments/assets/483a60c6-2f78-43b6-9f46-8f3f5ee54603)

메모리가 업데이트되면 캐시도 같이 업데이트해서 일관화를 이끌어내는 것은 중요하다.<br />
멀티 프로세서에서는 공유 메인 메모리를 기반으로 각자의 캐시를 가지게 되는데, 분명히 프로세서별 캐시 데이터가 다를 수 있다.<br />
이때 **메인 메모리로 데이터를 동기화할 때 어떤 프로세서가 기준이 될 지**를 고려해야 한다.

### 3. JVM에서의 개념 접목

자바의 대표적인 특징이 **멀티 스레딩**이다.<br />
멀티 스레드가 동일 메모리 영역에 접근할 때, 메모리 일관성을 유지해야 한다.<br />
바로 이 **메모리 일관성을 유지하기 위한 자체적인 메모리 모델(JMM : Java Memory Model)이, 캐시 일관성 프로토콜을 위한 메모리 모델과 유사**하다.<br />
어떻게 보면 하드웨어에서의 캐시 일관성을 위한 향상책 고민이 곧 JVM에서의 동시성 문제 해결을 위한 고민과 일맥상통한다고 볼 수 있다.

