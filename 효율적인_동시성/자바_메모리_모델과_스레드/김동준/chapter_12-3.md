# 12.3

## 자바에서의 메모리 구조

`멀티 프로세서 <-> 캐시 <-> 메인 메모리` 구조처럼 자바에서의 메모리 구조도 `멀티 스레드 <-> 작업 메모리 <-> 메인 메모리`로 구성된다.<br />
물론 작업 메모리가 캐시와 완벽히 대응되는 구조는 아니다. 정확히는 **스레드의 로컬 메모리**에 해당한다.<br />
임시 저장소의 역할을 하며 동기화가 필요하다는 점은 같지만 캐시와의 차이점이 많은 편이다.

| **특징**            | **작업 메모리**                          | **캐시**                                   |
|---------------------|----------------------------------------|------------------------------------------|
| **개념**             | JVM의 논리적 모델 (소프트웨어 레벨)         | CPU 하드웨어의 물리적 메모리 계층             |
| **역할**             | 스레드가 메인 메모리와 독립적으로 작업하도록 지원 | CPU가 메인 메모리 접근 시간을 줄이기 위해 사용 |
| **위치**             | JVM 내부 (스택, 레지스터, 등)             | 프로세서 내부 또는 외부 (L1, L2, L3 캐시)       |
| **데이터 동기화**     | JMM 규칙에 따라 메모리 동기화 수행           | 캐시 일관성(Coherence) 프로토콜로 동기화 관리   |

### 1. 멀티 스레드에서 메모리 간 상호작용

>1. 메인 메모리에서 작업 메모리로 변수 복사
>2. 작업 메모리 내용 다시 메인 메모리로 동기화

위의 단계는 `잠금 -> 잠금 해제 -> 읽기 -> 적재 -> 사용 -> 할당 -> 저장 -> 쓰기` 순으로 이뤄진다.<br />
다만 이 순서는 단일 메모리의 관점에서의 작업 순서이고 복수의 메모리 간에서는 뒤죽박죽 섞인 형태다.<br />
JMM에서는 **스레드의 작업 메모리와 메인 메모리 간 동기화가 명확하게 보장되지 않는다.**

> 1. A 스레드가 a 변수를 읽음
> 2. B 스레드가 b 변수를 읽고 연산하고 씀
> 3. A 스레드는 아직 연산하고 쓰는 작업 x

즉, JMM의 비결정적 실행 순서 및 동기화 부족으로 이런 일이 발생 -> **동시성 이슈**

### 2. 왜 이따구로 설계됐나?

#### (1) 작업 메모리의 존재

사실 이런 동시성 이슈를 해결하는 간단한 방법은, **직접 메인 메모리에 접근**하는 것.<br />
다만 이러면 결국 작업 메모리의 캐시로써의 의의가 사라지게 된다.<br />
또한, 스레드 간 순서 상호작용 강제 동기화는 상상을 초월하는 리소스를 소모한다. -> 엄청난 성능저하 유발

#### (2) 굳이 동기화를 보장할 필요가 없음

개발자가 필요한 부분에만 동기화를 강제하면 된다.<br />
동기화의 강제로 인한 병렬 처리의 장점을 잃을 바에는 필요한 곳에서만 동기화를 구축하면 된다.<br />
즉, **성능**과 **확장성**을 위해서이다.

## volatile 키워드

### 1. 예제 코드

#### (1) 595p 코드 12-1 수정

```java
public class VolatileTest {
    public static volatile int race = 0;

    public static void increase() {
        race++;
    }

    private static final int THREADS_COUNT = 20;

    public static void main(String[] args) {
        Thread[] threads = new Thread[THREADS_COUNT];
        System.out.println("스레드 카운트 : " + THREADS_COUNT);

        for (int i = 0; i < THREADS_COUNT; i++) {
            threads[i] = new Thread(() -> {
                for (int j = 0; j < 10000; j++) {
                    increase();
                }
            });
            threads[i].start();
        }

        for (int i = 0; i < THREADS_COUNT; i++) {
            try {
                threads[i].join();
            } catch (InterruptedException e) {
                System.err.println(e.getMessage());
            }
        }

        // 예상 : 200000
        System.out.println("결과 : " + race);
    }
}
```

`Thread.activeCount()`는 현재 JVM 내의 모든 스레드 개수를 반환하게 된다.<br />
만약 별개의 클래스에서 구현하면 메인 스레드는 종료되지 않으므로 무한루프에 걸리게 된다.<br />
즉, 모든 스레드가 종료됐는지 여부만 판별하고 특정 스레드의 세부적인 종료 여부는 고려하지 않기 때문에 적절한 메소드가 아니라고 생각했다.<br />

`Thread.yield()`는 다른 스레드의 종료 대기를 보장하지 않음. 반대로 `join()`은 다른 스레드의 종료 대기를 보장함.

#### (2) 실행 결과

<img width="732" alt="스크린샷 2024-11-23 오후 6 26 27" src="https://github.com/user-attachments/assets/6c233412-df07-4e29-9256-baa9a540326c">

### 2. 개념 정리

#### (1) 정의 및 용도

`volatile` 키워드는 **자바 코드의 변수를 메인 메모리에 저장할 것을 명시**한다.<br />
메인 메모리와 작업 메모리 간의 데이터 일관성을 보장하고, 변수의 쓰기 작업이 즉각 메인 메모리에 반영케 한다.<br />
두 개의 스레드가 `counter`라는 변수를 읽고 있다고 생각해보자.

![image](https://github.com/user-attachments/assets/69176b86-55d0-4b2a-b3ea-5ba799aa53fe)

스레드 1이 `counter` 변수를 0에서 7로 바꿔도, 스레드 2는 이를 모른다. 이를 **가시성의 문제**라고 한다.<br />
여기서 `counter` 변수에게 `volatile` 키워드를 부여하면 메인 메모리와 작업 메모리의 변수 값이 동일해질 수 있다.<br />
즉, 단일 스레드 상황에서는 메인 메모리와 작업 메모리 간의 변수 일관성을 유지할 수 있게 된다.

#### (2) 동시성 이슈의 해결책?

다만 이것을 멀티 스레드 상황으로 넓히면 상황이 복잡해진다.<br />
아래의 상황은, 멀티 스레드에서 메인 메모리의 `counter` 변수에 접근하면서 +1 하는 상황이다.

![image](https://github.com/user-attachments/assets/8d454459-3219-46ea-bcf7-8187de60d45d)

이것을 순전히 `volatile` 키워드만 쓰면, 단일 스레드 관점에서는 변수의 최신화는 보장된다.<br />
다만 그것이 복수의 스레드가 동시 접근하는 **경합 상황**에서는 전혀 소용이 없다.<br />

>1. 스레드1이 `counter` 변수에 접근해서 가지고 온다.
>2. 스레드2도 `counter` 변수에 접근해서 가지고 온다.
>3. 스레드1이 `counter` 변수에 +1 연산을 수행한다.
>4. 스레드1이 `counter` 변수를 쓴다. -> 여기에서 `volatile`이 있어도 메인 메모리 변수가 1일 뿐이다.
>5. 스레드2가 `counter` 변수에 +1 연산을 수행한다.
>6. 스레드2가 `counter` 변수를 쓴다. -> 여기에서도 `volatile`이 있어도 메인 메모리 변수가 1일 뿐이다.
>7. 우리가 기대했던 `counter` 변수 값이 2가 되지 않는다.
