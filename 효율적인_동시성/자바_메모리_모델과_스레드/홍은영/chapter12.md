## 12.1 들어가며
- 컴퓨터가 여러 작업을 동시에 하는 이유
  - 연산 능력이 뛰어나서
  - **저장, 통신 성능(디스크I/O, 네트워크 통신, DB 접근 등)과 격차가 너무 커서**
<br><br>


## 12.2 하드웨어에서의 효율과 일관성
**성능을 향상 시키는 방법**
1. 캐시 계층
  - 프로세서와 메모리 간 속도 차이를 해결하기 위해 캐시 사용
  - 데이터를 캐시에 복사해 작업을 빠르게 수행하고 결과를 캐시에서 메모리로 동기화

- 공유 메모리 멀티프로세서 시스템
  - 프로세서 각각이 자신만의 캐시를 가지고 같은 메인 메모리 공유
  - 캐시가 다를 경우 메모리로 동기화할 때 어떤 프로세서 데이터를 기준으로??
  -> 캐시 일관성(cache coherence) 문제 -> 데이터 경합 문제로 이어짐
  --> 캐시 일관성 프로토콜(MSI, MESI, MOSI, 시냅스 등)로 해결

2. 비순차 실행 최적화
  - 하드웨어: 프로세서가 명령어를 순서와 다르게 실행해 성능 극대화
  - JVM의 JIT 컴파일러 : '명령어 재정렬' 최적화 수행
<br><br>

## 12.3 자바 메모리 모델(JMM)
- 메모리 모델 : 특정 프로토콜을 이용해 특정 메모리나 캐시를 읽고 쓰는 절차
- 서로 다른 메모리 모델에서 자바 프로그램을 보호하려고 따로 만든 것. 플랫폼 상관없이 메모리를 일관된 방식으로 이용
- 다른 언어는 하드웨어와 운영 체제의 메모리 모델을 직접 사용 -> 플랫폼별 맞춤 제작
<br>

### 12.3.1 메인 메모리와 작업 메모리
- JMM
  - 프로그램에서 다양한 변수(인스턴스 필드, 정적 필드, 배열 원소)에 접근하는 규칙을 정하는 것이 주목적
  - 모든 변수가 메인 메모리(가상 머신이 관리하는 메모리)에 저장된다고 규정

- 작업 메모리
  - 스레드가 갖는 자체 메모리. 프로세서의 캐시와 비슷. 스레드 연산 수행
  - 메인 메모리 복사본을 저장하고, 메인 메모리 데이터는 직접 사용 X
  - 다른 스레드가 변수에 직접 접근 X, 메인 메모리 거쳐야 함
<br><br>

### 12.3.2 메모리 간 상호 작용
- 8가지 기본 연산
  - **잠금(lock)**
    - 메인 메모리 변수를 특정 스레드만 사용하도록 함
    - 다른 스레드에 의해 잠길 수 있음
    - 한 번에 한 스레드만 잠글 수 있지만 같은 스레드에서는 여러 번 가능
  - **잠금 해제(unlock)**
    - 다른 스레드에서 잠근 변수는 해제 불가
  - **읽기(read)**
    - 적재 연산 전 메인 메모리 변수를 작업 메모리에 **전송**
  - 적재(load)
    - 읽기 연산 결과값 **작업 메모리에 복사**
  - 사용(use)
    - 작업 메모리 값을 실행 엔진에 전달
  - 할당(assign)
    - 실행 엔진에서 받은 값 작업 메모리에 할당
    - 스레드는 할당값을 반드시 메인 메모리에 동기화 해야 함
  - 저장(store)
    - 쓰기 연산 전 작업 메모리 값을 메인 메모리에 **전송**
  - **쓰기(write)**
    - 저장 연산 결과값 메인 메모리에 기록
-> 읽기/적재, 저장/쓰기는 단독 수행 X
-> 작업 메모리에서 변수를 쓰려면 할당과 적재가 이뤄져야 함
<br><br>


### 12.3.3 volatile 변수용 특별 규칙
- volatile
  - JVM이 제공하는 가장 가벼운 동기화 메커니즘
  
**변수가 volatile로 정의될 때 특성**
1. 모든 스레드에서 변수를 투명하게 볼 수 있다
  - 값을 수정하면 다른 스레드에서도 새로운 값을 즉시 알 수 있다 -> 가시성만 보장
  - 일반 변수는 메인 메모리를 거쳐야 함

- 그럼 volatile는 동시성 환경에서 안전하다?? **X**
  - p.595) 20개 스레드에서 증가 연산(x++) 1만번 수행 -> 매번 200,000보다 작은 값이 다르게 출력
  - **why?** x++를 까보면 4개의 바이트 코드로 구성(p.596)
  - getstatic으로 값을 가져오고 iconst_1, iadd를 수행하는 동안 다른 스레드가 값을 변경하면 putstatic는 처음 getstatic를 기반으로 연산을 수행해서 메인 메모리에 동기화
  --> 바이트코드 명령어 하나가 기계어 명령어 여러 개로 변환되어 실행되면서 동시성 깨짐

- 해결방안 : 아래 2case에서는 락으로 원자성 보장
  - 락 : synchronized 키워드, concurrent 패키지와 원자적 클래스의 락
  case1. 연산 결과가 변수의 현재 값과 무관하거나 변수 값을 수정하는 스레드가 하나뿐임을 보장하지 않을 때 
  case2. 다른 상태 변수와 관련한 불변성 제약 조건에 관여할 때

2. 명령어 재정렬 최적화를 막아준다
  - 순차적인 시맨틱
  - 명령어 재정렬이 프로그램 동시 실행을 방해할 수 있음
  -> 재정렬로 코드가 조기 실행되어 다른 스레드 작업에서 에러 발생 가능

**volatile 중요성**
- 다른 동기화 도구보다 코드를 더 빨리 실행
  - 읽기 성능은 일반 변수와 비슷, 쓰기는 느림 -> 프로세서가 명령어 재정렬을 못하도록 메모리 장볍 명령어를 끼워넣어서
  - but, 대부분 상황에서 전체 부하는 lock보다 작음
  --> lock 대신 volatile 사용 권장
<br><br>

### 12.3.4 long과 double 변수용 특별 규칙
- long과 double의 비원자적 처리
  - 64비트 데이터의 적재, 저장, 쓰기 연산의 원자성을 보장할지 여부를 가상 머신이 선택하는 것
<br><br>

### 12.3.5 원자성, 가시성, 실행 순서
1. 원자성
  - JVM이 보장하는 원자적 변수 연산 8가지는 각 단계가 원자적으로 돌아감

2. 가시성
  - 공유 변수 값을 한 A스레드가 수정하면 결과를 다른 스레드에서도 즉각 볼 수 있는 것
  - 새로운 값을 즉시 메인 메모리로 동기화하고, 사용하면 즉지 메인 메모리에서 수정
  - synchronize : 잠금해제 전 변수 값을 메인메모리로 다시 동기화해서 가시성 확보
  - final : final 필드는 생성자에서 초기화 됨

3. 실행 순서
  - volatile : 명령어 재정렬 금지
  - synchronized : 락을 소유한 단 하나의 스레드만 변수에 접근할 수 있다.
  -> 각 키워드는 해당 규칙으로 작업 순서 보장

**결론**
  - 3가지 특성이 모두 필요하면 synchronized를 쓰는게 좋지만 남용하면 프로그램 성능 감소
<br><br>

### 12.3.6 선 발생 원칙
- 데이터 경합 발생 여부와 스레드 안전성을 확인하는데 유용한 수단
- 자연스러운 선 발생 관계
  - 프로그램 순서 규칙
  - 모니터 락 규칙
  - 휘발성 변수 규칙
  - 스레드 시작 규칙
  - 스레드 종료 규칙
  - 스레드 인터럽트 규칙
  - 종료자 규칙
  - 전이성
<br><br>

## 12.4 자바와 스레드
### 12.4.1 스레드 구현
- 스레드는 프로세스보다 가벼운 스케쥴링 단위
- 커널 스레드 : 운영 체제 커널에서 직접 지원하는 스레드. 스레드 작업을 각 프로세스에 매핑하는 역할


## 12.5 자바와 가상 스레드
### 12.5.1 커널 스레드의 한계
- JVM은 주로 1:1 커널 스레드 모델을 채택했음
- 과거에는 요청 처리 시간이 길어서 문제 X -> 현재는 요청이 짧고 자주 발생
- 스레드를 전환하는 비용이 작업 자체 계산 시간과 비슷할 정도로 비효율적 -> 짧은 작업을 처리하는 데 과도한 리소스 낭비
아지고 수가 많아지면서 사용자 스레드 전환 부하가 계산 자체의 부하에 근접하면서 심각한 낭비 초래
- I/O 요청이 오래걸릴 때 대기중에도 리소스를 점유
<br><br>

### 12.5.2 코루틴의 귀환
- 커널 스레드는 문맥을 저장하고 복원하는 과정에서 스케줄링 비용이 높다 -> 전환할 때 CPU 리소스 많이 사용
- 코루틴(사용자 스레드)은 개발자가 직접 제어하는 협력적 스케줄링으로 작동. 커널 보다 훨씬 가볍고 효율적
  - 스택풀 코루틴 : 전체 호출 스택을 저장하고 복원하는 방식. 스택을 통째로 관리해서 비용이 높을 수 있음
  - 스택리스 코루틴 : 유한 상태 머신처럼 동작하고 상태를 클로저에 저장. 스택을 복원할 필요가 없어 스택풀보다 가볍지만 기능이 제한적. await, async, yield. 
<br><br>

### 12.5.3 가상 스레드: 자바의 해법
- 스택풀 코루틴을 기반으로 구현된 가벼운 스레드
- 기존의 플랫폼 스레드와 다르게 JVM 내부에서 스케줄링되고 관리됨
- 플랫폼 스레드(기존 자바 스레드)와 N:1 관계
- 블로킹 I/O 작업이 많을 때 뛰어난 성능 발휘 -> 가상 스레드가 멈춰도 같은 플랫폼 스레드의 다른 가상 스레드는 계속 실행 -> CPU 리소스 낭비 최소화
<br><br>


