# 5부: 효율적인 동시성

동시성은 현대 컴퓨터의 계산 능력을 최대한 활용하기 위한 강력한 도구입니다. 여러 작업을 동시에 수행함으로써 응답 시간을 줄이고, 시스템의 효율성과 성능을 향상시킬 수 있습니다.

## 12장: 자바 메모리 모델과 스레드

### 12.1 들어가며

오늘날의 컴퓨팅 환경에서는 여러 작업을 동시에 처리해야 하는 요구가 증가하고 있습니다. 특히 서버나 대규모 애플리케이션에서는 동시에 많은 요청을 처리해야 하며, 이는 효율적인 동시성 프로그래밍을 필요로 합니다.

<br>

하지만 동시성 프로그래밍은 여러 스레드 간의 데이터 공유와 동기화 문제로 인해 복잡하고 어려운 기술입니다. 자바는 이러한 복잡성을 완화하기 위해 자바 메모리 모델(JMM)과 스레드 관련 기능을 제공합니다.

### 12.2 하드웨어에서의 효율과 일관성

#### 프로세서와 메모리의 속도 차이

프로세서는 매우 빠른 속도로 연산을 수행하지만, 메인 메모리의 접근 속도는 상대적으로 느립니다. 이로 인해 프로세서의 연산 능력을 충분히 활용하지 못하는 병목 현상이 발생합니다.

#### 캐시의 등장과 캐시 일관성 문제

이러한 속도 차이를 해소하기 위해 **캐시(Cache)**가 도입되었습니다. 캐시는 프로세서와 메인 메모리 사이에 위치하여 자주 사용하는 데이터를 빠르게 접근할 수 있도록 합니다.

<br>

그러나 멀티프로세서 시스템에서는 각 프로세서가 자체 캐시를 가지고 있어 캐시 일관성(Cache Coherence) 문제가 발생합니다. 한 프로세서가 메모리를 변경해도 다른 프로세서의 캐시에 그 변경 사항이 즉시 반영되지 않을 수 있습니다.

#### 메모리 모델과 명령어 재정렬

캐시 일관성 문제를 해결하기 위해 하드웨어 수준에서 메모리 모델과 캐시 일관성 프로토콜이 사용됩니다. 또한 프로세서의 성능 향상을 위해 **명령어 재정렬(Instruction Reordering)**과 **비순차 실행(Out-of-Order Execution)**이 활용되는데, 이는 프로그램의 실행 순서가 코드 작성 순서와 다를 수 있음을 의미합니다.

<br>

이러한 최적화는 성능 면에서 이점이 있지만, 동시성 프로그래밍에서는 예상치 못한 결과를 초래할 수 있습니다.

### 12.3 자바 메모리 모델

#### 자바 메모리 모델의 필요성

자바는 다양한 플랫폼에서 동일한 동작을 보장하기 위해 **자바 메모리 모델(JMM)**을 정의합니다. JMM은 스레드가 메모리에 접근하고 상호 작용하는 방식을 규정하여 일관된 프로그램 동작을 보장합니다.

#### 메인 메모리와 작업 메모리

JMM에서는 모든 변수가 메인 메모리에 저장되며, 각 스레드는 자신의 **작업 메모리(Working Memory)**를 가지고 있습니다. 스레드는 변수를 사용할 때 메인 메모리에서 작업 메모리로 변수를 가져와 사용하고, 변경된 값은 다시 메인 메모리에 저장합니다.

<br>

이러한 구조로 인해 스레드 간에 변수의 변경 사항이 즉시 반영되지 않을 수 있으며, 이를 메모리 가시성(Memory Visibility) 문제라고 합니다.

#### volatile 키워드

변수의 변경 사항이 즉시 다른 스레드에 반영되도록 하기 위해 volatile 키워드를 사용할 수 있습니다. volatile로 선언된 변수는 다음과 같은 특징을 가집니다.

- 가시성 보장: 한 스레드가 변수의 값을 변경하면 즉시 메인 메모리에 저장되며, 다른 스레드는 메인 메모리에서 그 값을 읽어옵니다.
- 명령어 재정렬 방지: 컴파일러와 프로세서의 최적화에 의해 명령어 순서가 변경되는 것을 방지합니다.

```java
public class VolatileExample {
    private volatile boolean flag = false;

    public void updateFlag() {
        flag = true;
    }

    public void checkFlag() {
        if (flag) {
            // flag가 변경되었음을 감지
        }
    }
}
```

하지만 volatile은 복합 연산의 원자성을 보장하지 않으므로 주의가 필요합니다.

#### 원자성(Atomicity)과 동기화

복합 연산(예: i++)은 읽기와 쓰기가 결합된 연산으로, 여러 스레드가 동시에 접근하면 예상치 못한 결과를 가져올 수 있습니다. 이를 해결하기 위해 synchronized 키워드를 사용하여 원자성을 보장할 수 있습니다.

```java
public class Counter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }
}
```

synchronized를 사용하면 한 번에 하나의 스레드만 해당 메서드나 블록을 실행할 수 있어 데이터의 일관성을 유지할 수 있습니다.

### 12.4 자바와 스레드

#### 스레드의 개념과 운영체제의 스레드 모델

스레드는 프로세스 내에서 실행 흐름을 분리하여 동시에 여러 작업을 수행할 수 있게 합니다. 운영체제는 스레드를 관리하는 방식에 따라 커널 스레드, 사용자 스레드, 하이브리드 스레드 모델을 제공합니다.

- 커널 스레드: 운영체제가 관리하며, 각 스레드는 운영체제의 스케줄러에 의해 관리됩니다.
- 사용자 스레드: 애플리케이션 레벨에서 관리되며, 운영체제는 단일 스레드로 인식합니다.
- 하이브리드 스레드: 사용자 스레드와 커널 스레드가 매핑되어 운영됩니다.

#### 자바 스레드와 JNI

자바에서 스레드를 생성하면 실제로는 운영체제의 커널 스레드가 생성됩니다. 이는 **JNI(Java Native Interface)**를 통해 자바가 운영체제의 기능을 활용하기 때문입니다.

<br>

Thread 클래스의 start() 메서드를 보면 내부적으로 네이티브 메서드 start0()를 호출하여 스레드를 시작합니다.

```java
public class Thread {
    // ...

    public synchronized void start() {
        // ...
        start0();
    }

    private native void start0();
}
```

#### 기존 스레드 모델의 한계

기존의 자바 스레드는 운영체제의 스레드와 1:1 매핑되므로 많은 수의 스레드를 생성하면 메모리 소비와 스케줄링 오버헤드가 증가합니다.

- 메모리 소비: 각 스레드는 독립적인 스택 메모리를 가지며, 많은 스레드를 생성하면 메모리 사용량이 크게 증가합니다.
- 스케줄링 오버헤드: 운영체제의 스케줄러가 많은 스레드를 관리해야 하므로 컨텍스트 스위칭 비용이 증가합니다.

#### 가상 스레드(Virtual Threads)의 도입

이러한 문제를 해결하기 위해 JDK 21에서는 **가상 스레드(Virtual Threads)**가 도입되었습니다. 가상 스레드는 경량화된 스레드로, 운영체제의 스레드와 1:1 매핑되지 않고 자바 레벨에서 관리됩니다.

- 경량성: 스레드 생성 비용이 낮으며, 수많은 스레드를 생성할 수 있습니다.
- 높은 동시성: 블로킹 I/O 작업에서도 스레드가 블로킹되지 않고 효율적으로 처리됩니다.
- 코드의 간결성: 비동기 프로그래밍의 복잡성을 줄이고, 동기식 코드 스타일을 유지하면서도 높은 성능을 제공합니다.

```java
public class VirtualThreadExample {
    public static void main(String[] args) {
        Thread.startVirtualThread(() -> {
            // 가상 스레드에서 실행할 코드
            System.out.println("가상 스레드 실행 중");
        });
    }
}
```

## 결론

동시성 프로그래밍은 현대 애플리케이션에서 필수적이지만 복잡한 분야입니다. 자바는 자바 메모리 모델과 스레드 기능을 통해 이러한 복잡성을 완화하고 개발자가 안정적이고 효율적인 동시성 코드를 작성할 수 있도록 지원합니다.

<br>

특히, 가상 스레드의 도입은 자바에서 동시성 프로그래밍의 새로운 가능성을 열어주었으며, 더 많은 스레드를 효율적으로 관리하고 높은 성능을 제공할 수 있게 되었습니다.

<br>

추가로, 동시성과 병렬성 등 다양한 개념에 대해서 따로 정리하는 시간을 갖으면 해당 챕터를 이해하는데에 도움이 될 것 같습니다.
