### Javac (Java Compiler) : .java -> .class 변환 실행 패키지

<br>

>  .java 파일을 (jvm에서 실행할 수 있도록).class로 바이트코드로 변환 (java는 compile언어)

<br>

```BASH
# HelloWorld.class 바이트코드생성 명령어 
javac HelloWorld.java
```

<br><br>

### Javac의 컴파일 과정

<br>

>구문 분석 (Syntax Analysis)
>
> 심볼 테이블 채우기
>
> 애너테이션처리
>
> 의미 분석 (Semantic Analysis)
>
> 바이트코드 생성 

<br>

### Java Compile 과정에서 사용되는 라이브러리 알아보기
(필드엔 뭐가있고 각각 어떤기능을 하는 함수들이 있는지 정도만 훑어보면 좋을 듯 하다)

<br>

> eclipes 기준 Project and External Dependencies/JRE System Library에서 라이브러리를 가져와 사용하고있는 것을 볼 수 있다.

| 구분       | Project and External Dependencies            | JRE System Library                        |
|------------|---------------------------------------------|-------------------------------------------|
| 포함 대상  | 외부 라이브러리, 프로젝트 간 의존성         | JDK/JRE에서 제공하는 기본 라이브러리       |
| 용도       | 추가 기능 및 도구 제공                     | Java 애플리케이션 실행 및 기본 기능 제공   |
| 관리 위치  | 사용자 또는 빌드 도구(Maven/Gradle)         | Eclipse가 자동으로 연결 (프로젝트 설정 기반) |


<br>

#### 1. 구문분석(Syntax Analysis) : 어휘 분석(lexical analysis) / 문법 트리 (Abstract Syntax Tree, AST) 변환
  - JRE System Libary -> jdk.compiler의 com.sun.tools.javac.parser 패키지
    - Scanner.java (implements Lexer)
    - JavacParser.java (implements Parser)
  - JRE System Libary -> jdk.compiler의 com.sun.tools.javac.tree 패키지
    - JCTree.java
<br>

> **어휘 분석(lexical analysis)**  : 소스코드의 문자스트림에서 토큰 집합으로 변환

- **Scanner.java** : Buffer로 받아서 읽고 Tokenizer로 토큰 생성
  - ( Token클래스의 분할기준으로 토큰 재분할(큰토큰),  에러시 에러위치도 저장 )

<br>

> **문법 트리 (Abstract Syntax Tree, AST)** 로 변환 : 토큰 기반 문법적 구조 파악, 추상 구문 트리 생성(구조적 관계)

- **JavaParser.java** : Scanner가 생성한 토큰 읽고 분석 및 AST(Abstract Syntax Tree)생성
  - ( 잘못된 문법은 구문 오류 발생,JCTree 클래스를 사용하여 트리 구조 표현)
  - (분석을위해 package com.sun.tools.javac.parser의 다양한 클래스들을 활용하고 있다. ex TreeMaker,Names)

- **JCTree.java** : Java 코드의 구문 표현하는 **추상 구문 트리 (AST)** 의 기본 클래스
  - ( 클래스 클래스 선언, 메서드 선언, 변수 선언, 조건문, 반복문 등 다양한 구문 요소를 트리의 노드로 변환)

<br>

###### 추상 구문 트리 (AST) 생성 예시

```JAVA
int a = b + c * d;
```
```PYTHON
      VariableDeclaration
          /        \
        Type       Assignment
        /            /     \
     int         +       Literal
                 /   \
               b     *
                     / \
                   c   d

```

######  노드는 다른 노드 객체를 포함할 수 있음 이후 구문적인 관계를 파악 및 최적화나 에러체크를 함


<br>

###### 참고 )))

| ![image](https://github.com/user-attachments/assets/2731cb0d-bb62-44cf-b233-9c24e72abc83) | ![image](https://github.com/user-attachments/assets/a894c6d6-ae16-43c5-bcba-edad9bfcb4f8) |
---|---|

> 위 이미지중 java.compiler와 jdk.complier중에 javacompile역할을 하는것은 jdk.complier 이다
>
> Java 런타임 라이브러리와 JDK 관련 추가 라이브러리로
>
> jdk.compiler Java 컴파일러의 핵심 구현을 포함하는 모듈이며 com.sun.tools.javac이 javac의 핵심구현을 포함한다
>
> java.compiler는 Java 컴파일러 API를 제공하는 모듈 외부 애플리케이션이 컴파일 기능을 사용할 수 있도록 하는 인터페이스를 정의한다
>
> (javax.tools 패키지 : 컴파일러를 제어하는 API 제어)
>
> java.compiler모듈의 javax.tools패키지의 JavaCompiler.interface
>
> com.sun.tools.javac.main.JavaCompiler가 이의 구현체다
>
> build.gradle javacompile task를 커스텀해서 컴파일하고싶을때 사용하는 JavaCompiler API 이다.
>

# `jdk.compiler` vs `java.compiler`

| **특징**      | **`jdk.compiler`**                                | **`java.compiler`**                                |
|---------------|--------------------------------------------------|--------------------------------------------------|
| **주요 목적**  | `javac`의 실제 구현을 포함하는 모듈               | Java 컴파일 API를 제공하여 컴파일러를 제어        |
| **용도**       | Java 소스 파일을 실제로 컴파일하는 도구 및 클래스  | 외부 애플리케이션에서 컴파일을 트리거할 수 있는 API |
| **구성 요소**  | `com.sun.tools.javac` 패키지 (컴파일러 구현)       | `javax.tools.JavaCompiler` (컴파일 API 제공)       |
| **예시**       | `javac` 명령어 실행, 컴파일러의 내부 구현         | Java 소스를 프로그램matically 컴파일하는 코드 예시 |


#### 2. 심볼 테이블 채우기/ 의미 분석 (Semantic Analysis)
(문법오류는 Paser/ 타입검사등은 심벌테이블체우면서함)

- **com.sun.tools.javac.comp.Enter.java** : 심벌 처리 및 AST기반 심벌 테이블 채우는 작업 수행 
  - 식별자(변수, 메서드, 클래스 등)들의 정보를 저장하고 관리
  - (식별자 타입, 범위(scope), 사용 위치 등을 기록)
  - Enter는 JCTree에서 구문 요소를 추출

- **com.sun.tools.javac.comp.Resolve.java** : 심벌 테이블 사용, 타입 해석과 바인딩 진행
  - 타입 검사,연결하면서 유효성 검증, 호출 검사 처리를 통해 논리적 오류를 사전에 차단

- **com.sun.tools.javac.comp.Symbol.java** (심벌 객체): 수, 메서드, 클래스 등의 식별자(심벌)를 표현
  - (이름, 타입, 스코프 등과 관련된 정보를 포함)

- **com.sun.tools.javac.comp.Symtab.java**(심벌 테이블 클래스):심벌 테이블 관리
  - 심벌을 검색하거나 추가하는 작업

#### 3. 애너테이션처리 : Java 소스 코드 내에서 사용된 애너테이션 처리

- **com.sun.tools.javac.processing.JavacProcessingEnvironment** : 
  - 컴파일러와 애너테이션 처리기 상호작용 및 (인터페이스 제공) 및 어노테이션 처리기 관리(환경 세팅 등)
  - 해당 클래스의 inner class에 Round클래스가 정의되어있음 (어노테이션처리 단위를 정의)
  - ( javax.annotation.processing.AbstractProcessor : annotationProcessor의 추상클래스 )
  - (AbstractProcessor는 또 Processor인터페이스를 받고있음)
  - 필드에 private final JavaCompiler compiler 정의되어있음
  - (com.sun.tools.javac.main.JavaCompiler.java)
  - (해당 소스코드를 보면 task 단위로 실행됨을 알수 있다. -> taskEvent,taskListener )
  - (gradle설정에서도 task단위로 설정 할 수 있음)
  - 필드로 선언된 JavaCompiler compiler 에서 
  - initProcessAnnotations() : 애너테이션 처리기생성
  - processAnnotations() : 애너테이션 처리기를 실행

실제 AnnotationProcessor는 javax.annotation.processing.AbstractProcessor 클래스를 상속하여 구현됨

![image](https://github.com/user-attachments/assets/0d687df9-e07f-434f-8483-8225bac8290e)

 **AbstractProcessor**를 상속한 클래스들이 process() 메서드를 통해 애너테이션을 받아 처리하는데
 위 사진처럼 라이브러리 별로 process를 구현해 처리하는것 같다 

#### 4. 바이트코드 생성 (Bytecode Generation)

- **com.sun.tools.javac.jvm.Gen.java** 
  - Code: 바이트코드를 생성하는 클래스, JCTree와 Symbol로 바이트코드 생성
  - Gen: 클래스와 메서드의 바이트코드를 생성하는 주요 클래스
  - ClassWriter: .class 파일로 출력

