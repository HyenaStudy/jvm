### Javac (Java Compiler) : .java -> .class 변환 실행 패키지

<br>

>  .java 파일을 (jvm에서 실행할 수 있도록).class로 바이트코드로 변환 (java는 compile언어)

<br>

```BASH
# HelloWorld.class 바이트코드생성 명령어 
javac HelloWorld.java
```

<br><br>

### Javac의 컴파일 과정

<br>

>구문 분석 (Syntax Analysis)
>
> 심볼 테이블 채우기
>
> 애너테이션처리
>
> 의미 분석 (Semantic Analysis)
>
> 바이트코드 생성 

<br>

### Java Compile 과정에서 사용되는 라이브러리 알아보기

<br>

> eclipes 기준 Project and External Dependencies/JRE System Library에서 라이브러리를 가져와 사용하고있는 것을 볼 수 있다.

| 구분       | Project and External Dependencies            | JRE System Library                        |
|------------|---------------------------------------------|-------------------------------------------|
| 포함 대상  | 외부 라이브러리, 프로젝트 간 의존성         | JDK/JRE에서 제공하는 기본 라이브러리       |
| 용도       | 추가 기능 및 도구 제공                     | Java 애플리케이션 실행 및 기본 기능 제공   |
| 관리 위치  | 사용자 또는 빌드 도구(Maven/Gradle)         | Eclipse가 자동으로 연결 (프로젝트 설정 기반) |


<br>



#### 1. 구문분석(Syntax Analysis) : 어휘 분석(lexical analysis) / 문법 트리 (Abstract Syntax Tree, AST) 변환
  - JRE System Libary -> jdk.compiler의 com.sun.tools.javac.parser 패키지 Scanner.java (implements Lexer), JavacParser.java(implements Parser)
  - JRE System Libary -> jdk.compiler의 com.sun.tools.javac.tree 패키지 JCTree.java

> **어휘 분석(lexical analysis)**  : 소스코드의 문자스트림에서 토큰 집합으로 변환
> 
> **문법 트리 (Abstract Syntax Tree, AST)** 로 변환 : 토큰 기반 문법적 구조 파악, 추상 구문 트리 생성(구조적 관계)

Scanner : Buffer로 받아서 읽고 Tokenizer로 토큰화, Token클래스의 분할기준으로 토큰 분할(큰토큰),  에러시 에러위치도 저장
JavaParser: Scanner가생성한 토큰 읽고 분석 및  AST(Abstract Syntax Tree) 생성,잘못된 문법이 있으면 구문 오류를 발생,JCTree 클래스를 사용해 트리 구조로 표현
JCTree : Java 코드의 구문을 표현하는 **추상 구문 트리 (AST)**의 기본 클래스 클래스 선언, 메서드 선언, 변수 선언, 조건문, 반복문 등 다양한 구문 요소를 트리의 노드로 변환

| ![image](https://github.com/user-attachments/assets/2731cb0d-bb62-44cf-b233-9c24e72abc83) | ![image](https://github.com/user-attachments/assets/a894c6d6-ae16-43c5-bcba-edad9bfcb4f8) |
---|---|

###### 참고 )))

> 위 이미지중 java.compiler와 jdk.complier중에 javacompile역할을 하는것은 jdk.complier 이다
>
> Java 런타임 라이브러리와 JDK 관련 추가 라이브러리로
>
> jdk.compiler Java 컴파일러의 핵심 구현을 포함하는 모듈이며 com.sun.tools.javac이 javac의 핵심구현을 포함한다
>
> java.compiler는 Java 컴파일러 API를 제공하는 모듈 외부 애플리케이션이 컴파일 기능을 사용할 수 있도록 하는 인터페이스를 정의한다
>
> (javax.tools 패키지 : 컴파일러를 제어하는 API 제어)
>
> java.compiler모듈의 javax.tools패키지의 JavaCompiler.interface
>
> build.gradle javacompile task를 커스텀해서 컴파일하고싶을때 사용하는 JavaCompiler API 이다.
>

# `jdk.compiler` vs `java.compiler`

| **특징**      | **`jdk.compiler`**                                | **`java.compiler`**                                |
|---------------|--------------------------------------------------|--------------------------------------------------|
| **주요 목적**  | `javac`의 실제 구현을 포함하는 모듈               | Java 컴파일 API를 제공하여 컴파일러를 제어        |
| **용도**       | Java 소스 파일을 실제로 컴파일하는 도구 및 클래스  | 외부 애플리케이션에서 컴파일을 트리거할 수 있는 API |
| **구성 요소**  | `com.sun.tools.javac` 패키지 (컴파일러 구현)       | `javax.tools.JavaCompiler` (컴파일 API 제공)       |
| **예시**       | `javac` 명령어 실행, 컴파일러의 내부 구현         | Java 소스를 프로그램matically 컴파일하는 코드 예시 |


###### 심볼 테이블 채우기
식별자(변수, 메서드, 클래스 등) 정보를 저장
(식별자 타입, 범위(scope), 사용 위치 등을 기록)

com.sun.tools.javac.comp Enter  구문 분석 후 AST를 기반으로 심벌 테이블을 채우는 작업을 수행 : AST를 순회하면서 변수, 메서드, 클래스 등의 심벌을 심벌 테이블에 등록
Enter는 JCTree에서 구문 요소를 추출
심벌 테이블에 변수, 메서드, 클래스 등을 등록하고 스코프와 중복 정의를 확인
com.sun.tools.javac.symbol 패키지의 Symbol 클래스는 심벌 테이블에 대한 데이터를 관리하고, 심벌의 메타데이터(이름, 타입, 스코프 등)를 저장
**Enter**가 심벌 테이블을 채우고 등록하는 과정에서 **com.sun.tools.javac.symbol**의 Symbol 클래스가 사용

###### 애너테이션처리
메타데이터를 코드에 추가하는 방식
컴파일 타임에 처리기(annotation processor)에 의해 처리
javac는 컴파일할 때 애너테이션을 처리하는 특별한 프로세서를 호출
붙은 클래스나 메서드를 찾아서 코드를 생성하거나 처리

javax.annotation.processing

JavacProcessingEnvironment: 애너테이션 처리기의 환경을 설정하고, 애너테이션 처리기를 실행합니다.
Round: 애너테이션 처리기의 한 라운드에 대한 정보를 제공합니다.
AnnotationProcessor: 애너테이션 처리의 실제 로직을 구현하는 클래스입니다. 각 애너테이션에 대해 수행할 작업을 정의합니다.

애너테이션 발견: 컴파일 과정 중 애너테이션이 발견되면 애너테이션 처리기가 실행됩니다.
애너테이션 처리: AnnotationProcessor가 애너테이션을 처리하여 필요한 작업을 수행합니다.
결과 생성: 애너테이션 처리 후, 애너테이션에 대한 새로운 파일이나 수정된 파일이 생성될 수 있습니다.


###### 의미 분석 (Semantic Analysis)
코드의 논리적 오류를 체크
타입 검사와 호출 검사를 통해 실행 시 발생할 수 있는 오류체크
타입 검사, 변수 사용 전 선언 여부 등을 체크

com.sun.tools.javac.comp.Resolve 두번째단계내용이랑 겹치는듯?

의미 분석은 주로 com.sun.tools.javac.comp.Resolve 클래스와 com.sun.tools.javac.comp.Enter 클래스에서 수행됩니다.
**Resolve**는 타입 검사와 호출 검사를 처리하며, **Enter**는 심벌 테이블을 채우고 스코프와 변수 선언 여부를 점검합니다.
**Symbol**과 Symtab 클래스는 심벌 테이블을 관리하는 데 중요한 역할을 하며, 의미 분석에서 심벌의 타입과 스코프를 추적합니다.
이 과정들을 통해 javac는 코드의 타입 오류와 변수 선언 오류를 검출하고, 논리적 오류를 사전에 차단


###### 바이트코드 생성 (Bytecode Generation)

com.sun.tools.javac.jvm:

Code: 바이트코드를 생성하는 클래스입니다. JCTree와 Symbol을 바탕으로 바이트코드를 생성합니다.
Gen: 클래스와 메서드의 바이트코드를 생성하는 주요 클래스입니다.
ClassWriter: 클래스의 바이트코드를 생성하고, 이를 .class 파일로 출력

중간 코드 생성: AST를 바탕으로 중간 코드가 생성됩니다.
바이트코드 생성: Gen 클래스가 중간 코드를 바탕으로 실제 바이트코드를 생성합니다.
.class 파일 출력: 생성된 바이트코드는 .class 파일로 출력됩니다
