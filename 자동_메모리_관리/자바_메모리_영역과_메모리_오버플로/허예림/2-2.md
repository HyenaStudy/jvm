### 2.1 들어가며

JVM에서 자동 메모리 관리를 수행하기 때문에 자연스럽게 개발자는 메모리 누수나 오버플로우 문제를 겪지 않게 되었다. JVM이 관리하는 메모리 영역과 관리 대상, 문제점들에 대해 설명하는 장이다.

### 2.2 JVM의 메모리 구조

**프로그램 카운터 레지스터**

- 현재 실행 중인 스레드의 바이트 코드 줄 표시기 → 현재 실행중인 명령어 추적
- 각 스레드는 독립된 PC 레지스터 보유 → 스레드 안전성 보장
- 바이트 코드 인터프리터는 이 카운터의 값을 바꿔 다음 실행할 바이트코드 명령어를 선택하는 식으로 동작합니다.
- 스레드와 함께 유지되며 GC의 대상이 아닙니다.

**자바 가상 머신 스택**

- 가상 머신 스택은 자바 메서드를 실행하는 스레드의 메모리 모델을 설명해준다.
- 각 메서드가 호출될 때마다 자바 가상 머신은 스택 프레임을 만들어 지역 변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값등의 정보를 저장한다. 그런 다음 스택 프레임을 가상 머신 스택에 푸시하고 메서드가 끝나면 팝하는 일을 반복한다.
- 메서드 호출 시마다 각각 스택 프레임이 생성되고, 메서드 안에서 사용되는 값들을 저장하고 호출된 매개변수, 지역 변수, 리턴 값 및 연산 시 일어나는 값들을 임시로 저장한다.

**네이티브 메서드 스택 (Native Method Stack)**

- 운영체제와의 상호작용을 위해 네이티브 코드가 실행될 때 호출되는 스택입니다.
- JNI (Java Native Interface) 호출 지원
- JVM 스택과는 별도로 관리됩니다.
- 각 스레드마다 독립적인 네이티브 메서드 스택이 생성됩니다.

**자바 힙**

- 실행 중에 생성되는 객체와 배열 저장
- 공유 메모리 : JVM 내의 모든 스레드가 공유합니다.
- GC 대상
- 구조 : Young Generation (새로운 객체) + Old Generation (오래 살아남은 객체) + Java 8이후 Metaplace (클래스 메타 데이터)

**메서드 영역**

- 클래스 메타 데이터, 매서드 바이트 코드, 클래스 로드 시 초기화에 필요한 데이터와 인터페이스 메서드 구현에 대한 정보 등이 저장되어 있습니다.
- 공유 메모리 : JVM 내의 모든 스레드가 공유합니다.
- 런타임 상수 풀
    - 상수와 필드, 메서드, 클래스 참조가 저장됨
    - 컴파일 시 생성된 상수 정보를 런타임에 관리

**번외. 다이렉트 메모리**

- JVM 힙 외부에서 관리되는 메모리 영역 → GC에 직접 관리되지 않지만 할당 및 해제 추적
- java.nio.ByteBuffer의 DirectByteBuffer에 의해 접근
- 운영체제 메모리 관리 시스템을 사용하므로 고성능 I/O, 네트워크 통신 등에 사용