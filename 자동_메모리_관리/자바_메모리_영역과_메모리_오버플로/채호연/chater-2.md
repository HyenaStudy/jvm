# Chapter 2 : 자바 메모리 영역과 메모리 오버 플로우

## 2.0 들어가며 : 왜 JVM의 메모리 관리 방식을 이해해야 하는가?
JVM의 자동 메모리 관리 메커니즘은 더 이상 사용되지 않는 객체에 대한 GC 및 객체 생명 주기 상 소멸이 된 객체가 점유하던 메모리 공간에 대한 점유 해제와 같은 메모리 관리를 자동으로 수행해준다.

그러나 역시 이러한 자동 메모리 관리 메커니즘도 완벽할 수 없기에 문제가 된다.

바로 이때 해당 부분에서 문제가 발생했을 때 JVM의 메모리 관리 방식이나 JVM의 메모리 구조에 대한 이해가 없다면 원인을 파악하기도, 해결하기도 굉장히 어려워지기 때문.

따라서 JVM의 메모리 관리 및 활용 방식과 그 구조에 대한 이해가 필요하다.


## 2.1 JVM에게 주어지는 '메모리'
JVM이 자신에게 허락된 '메모리'를 어떻게 구조화하고 활용하는가를 살펴보기 이전에 JVM에게 정확히 '무엇이', '누군가에 의해' 할당되는 지 살펴볼 필요가 있다. \
책에서는 메모리, 메모리 노래를 부르다가 갑자기 어딘가에서 '네이티브 메모리' 라는 용어를 사용한다. 그렇다면 우리가 지금까지 '메모리'라고 부르던 녀석은 무엇인가?




## 2.2 런타임 데이터 영역(Runtime Data Area)

<img src = https://velog.velcdn.com/images/impala/post/a8a3fbaa-9396-4dd8-845f-e59746b4af8c/image.PNG width = "1200">
<small>Image from https://velog.io/@impala/JAVA-JVM-Runtime-Data-Area</small>

#### 정의
> 프로그램이 실행되는 동안 JVM이 생성 및 관리하는 메모리 영역

#### 구분
- 런타임 데이터 영역의 각 영역은 저마다 별도의 목적을 가진다.
- 그러나 <u>생성 시점 및 스레드 접근성</u>에 따라 크게 두 가지로 나누어 구분할 수 있다.
  - a. 가상 머신 프로세스의 시작 시점에 생성되는 영역 : *스레드 간 공유 영역*
    - ex. *Heap Area*, *Method Area*
  - b. 사용자 스레드 시작 시점에 생성되는 영역 : *스레드 간 공유 불가 영역*
    - ex. *Stack Area*, *PC Register*, *Native Method Stack*

<br>

> PS. 자바 클래스 파일 실행 시작부터 실제 실행까지 클래스 로딩 및 링킹, 그리고 런타임 데이터 영역의 생성과 객체 할당 및 참조 과정 전반에 대한 정리가 있으면 좋겠다! 

### 2.2.1 Program Counter(PC Register)
#### 목적
> <u>현재 스레드가 실행 중인 바이트코드 명령어 저장된 주소</u>를 담아두는 레지스터(메모리 영역)

#### 존재 이유
멀티스레딩 구조에선 여러 스레드가 프로세서의 각 코어를 교대로 사용한다.

이러한 상황에서 어떤 스레드 A의 작업을 수행하다가 다른 스레드 B의 작업이 수행된 후, 다시 A로 돌아왔을 때 이전에 중단된 지점부터 다시 실행할 필요가 있다.

따라서 스레드 별로 *PC 레지스터* 가 존재하고 이 곳에 현재 실행 중인(혹은 이제 수행해야 하는) 명령어의 주소를 담아두는 것이다.

#### 특징
- Per-thread Area : 스레드 별로 PC 레지스터가 생성된다.
- <u>`OutOfMemoryError` 발생 조건이 **명시되지 않은** 유일한 영역</u>
- 어떤 메서드를 실행 중인지에 따라 PC 레지스터는 다른 값을 보관한다.
  - a. Java Method 실행 중일 경우 : 해당 바이트코드 명령어 주소
  - b. Native Method 실행 중일 경우 : `undefined`

<br>

## 2.2.2 Stack Area
#### 정의
> 스레드에서 Java 메서드 호출 시 생성되는 Stack Frame이 저장되는 스택 구조의 메모리 영역

> ***Stack Frame***
> - 메서드 호출 시 생성되어 메서드 실행 시 활용되는 데이터 구조이다.
> - 내부에 다음과 같은 정보를 보관한다.
>> 1. *지역변수 테이블(LVA, Local Variable Array)* : <u>컴파일 시점</u>에 알 수 있는 <u>실행 중인 메서드</u>의 파라미터, 메서드 내 지역변수와 같은 정보가 저장된 배열 형태의 공간.
>>> - 0번으로 시작하는 인덱스 구조를 가진다.
>>> - 각 인덱스 위치의 공간을 *슬롯(Slog)* 이라고 하며, 각 슬롯은 통상 32비트이다. 하지만 이는 JVM 구현에 따라 달라질 수 있다.
>>> - 그렇기 때문에 64비트 데이터가 저장될 경우 두 슬롯에 걸쳐 저장된다.
>>> - 컴파일 시점에 크기가 동적으로 결정되어 생성된다. 이렇게 결정된 지역변수 테이블 크기는 메서드 실행 중엔 절대로 변경되지 않는다.
>>> - 스레드 별로 존재한다.
>>> - 이때 해당 메서드가 `static`이 아닌 경우, 0번에는 해당 메서드가 속한 클래스 인스턴스(객체)로의 레퍼런스인 `this` 참조가 보관된다.
>> 2. *피연산자 스택(Operand Stack)* : 메서드 바이트 코드 실행 중 발생하는 중간 연산 결과물 및 피연산자를 저장하는 공간.
>> 3. 현재 실행 중인 메서드가 정의된 *클래스의 런타임 상수 풀(Runtime Constant Pool)로의 참조*

#### 존재 이유
1. 메서드 호출 관리
    - 스레드가 메서드를 호출할 경우, 해당 메서드의 지역변수와 파라미터, 인스턴스로의 참조, 중간 결과값 등 메서드 실행에 필요한 데이터를 담은 스택 프레임이 생성되고, 생성된 스택 프레임이 스택에 적재된다.
    - 메서드 실행이 완료되면 스택으로부터 해당 스택 프레임이 추출(popped-out) 된다.
2. 메서드의 지역 변수와 실행 상태들이 스레드 별로 생성된 스택에 저장됨으로써 스레드 독립성을 갖게 된다.

#### 특징
Stack 영역은 아래의 두 가지 문제가 발생할 수 있도록 설계되었다.

1. `OutOfMemoryError` : 가상 머신이 스레드 요청에 따라 스택 크기 확장하려할 때, JVM에 할당된 여유 메모리가 존재하지 않을 경우 발생.
2. `StackOverflowError` : 스레드가 요청한 스택의 깊이가 가상 머신이 허용하는 수준보다 높을 경우 발생.

## 2.2.3 네이티브 메서드 스택
#### 정의
> Native Method 실행 시 해당 메서드 실행에 필요한 정보를 담은 스택 프레임이 저장되는 공간

#### 존재 목적
> Native method의 원활한 실행

#### 특징
- JVM 명세 상 네이티브 메서드 스택의 구체적 구현 방향 명세되어 있지 않다.
- 그렇기 때문에 JVM Vendor의 의도에 따라 자유롭게 구현 및 설계 가능하다.
- Stack Area와 마찬가지로 `StackOverflowError`, `OutOfMemoryError` 발생 가능하다.


## Heap Area(Java Heap)
#### 정의
> 모든 자바 객체 인스턴스와 배열이 저장되는 동적 할당 메모리 영역. \
> (하지만 JVM의 발전 속도와 방향을 보았을 때 절대적으로 '모든'이라고 단정하기엔 어려운 부분이 있다.)

#### 특징
- 모든 스레드에 의해 공유되는 메모리 영역
  - 그렇기 때문에 메모리 할당 및 회수 효율을 높이기 위해 힙 영역은 '스레드 로컬 할당 버퍼 영역' 으로 나뉘어져있다.
- JVM 구동 시점에 생성 및 할당되는 메모리 영역
- 대부분의 자바 객체 인스턴스와 배열이 저장되는 영역이므로 ***GC* 가 이루어진다**.

#### JVM 명세 상 Heap Area 구현 시 요구사항
- 물리적으로 떨어져있어도 되나, **논리적으로 연속되어야 한다**.
  - 하지만 배열의 경우 물리적으로 연속되도록 저장하는 편이 참조 및 쓰기 효율이 좋기 때문에 실제로는 물리적으로도 연속되도록 저장되는 것이 일반적이다.
- Heap 영역의 크기는 고정과 확장 모두 가능하다.
  - 하지만 주류 JVM의 경우 확장 가능하도록 구현하는 추세.
  - JVM 실행 시 힙 영역 크기 설정을 위한 실행 파라미터로 `-Xmx`, `-Xms` 가 존재한다.
  - Heap 공간이 부족함과 동시에 확장 또한 불가할 경우 `OutOfMemory` 발생.

> Q. JVM이 사용가능한 메모리의 영역은 OS로부터 할당되는가? 그렇다면 이 또한 확장이 가능할까??


## Method Area(Metaspace)
#### 정의
> 클래스 레벨의 정보(클래스의 구조, 클래스의 메서드 및 메서드 바이트코드, 클래스 필드, 클래스별 런타임 상수 풀)과 같은 정보를 저장하는 메모리 영역

#### 특징
- 모든 스레드에 의해 공유되는 영역
- 클래스 로딩 시 로드된 클래스의 정보가 해당 영역에 저장된다.



