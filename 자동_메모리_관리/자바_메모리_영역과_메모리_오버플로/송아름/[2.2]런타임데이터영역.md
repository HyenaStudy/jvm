## 런타임 데이터 영역

> JVM 런타임 데이터 영역은 자바프로그램이 실행될 때 데이터를 저장하는 메모리 공간
> 동적으로 할당하고 사용되는 데이터와 정보를 저장
> runtime동안 필요한 데이터를 보관하고 관리하는 역할까지 수행

<br>

###### jvm runtime data area 구조도

![image](https://github.com/user-attachments/assets/07afab56-4497-4a75-ba6d-657e343d5222)



![image](https://github.com/user-attachments/assets/9edc8134-792d-414c-a619-98878ff05e6d)

<br>

#### 1. 메서드영역(~java 7/java8 ~)

<br>

> java8 이후로 Method Area는 Metaspace로 변경 <br>
> JVM의 메서드 영역의 구현 방식이 바뀜 <br>
> JVM의 메모리 관리 방식을 개선하기위해 도입되었다고 함 <br>

<br>

| **특징**               | **자바 8 이전**                      | **자바 8 이후**                      |
|----------------------|------------------------------------|------------------------------------|
| **메서드 영역**         | 메서드 영역 (PermGen)               | 메타스페이스 (Metaspace)            |
| **메모리 관리 방식**     | 고정된 크기 (PermSize, MaxPermSize 설정) | 동적 크기 조정 (자동 확장)            |
| **메모리 저장 위치**     | 힙 영역 내                          | 네이티브 메모리                     |
| **메모리 관련 오류**     | OutOfMemoryError: PermGen space    | OutOfMemoryError: Metaspace         |
| **JVM 메모리 옵션**      | -XX:PermSize, -XX:MaxPermSize       | -XX:MetaspaceSize, -XX:MaxMetaspaceSize |
| **가비지 컬렉션 관리**   | 메서드 영역은 가비지 컬렉션에서 제외   | 메타스페이스는 가비지 컬렉션에서 제외, 네이티브 메모리 관리 |

###### 비교

<div style="display: flex; justify-content: space-between;">
  <img src="https://github.com/user-attachments/assets/22db59c6-4dea-4981-8bbe-501caeaff3cd" style="width: 45%;" />
  <img src="https://github.com/user-attachments/assets/0dab6f03-77d9-495f-a2d3-c18f4daee232" style="width: 45%;" />
</div>

###### -XX:PermSize, -XX:MaxPermSize 로 사이즈가 고정되고 있다.

<br>

1. JVM 힙과 메타스페이스의 분리 
2. 동적 크기 확장

<br>

JVM 힙은 객체를 저장, 메타스페이스는 클래스 메타데이터(클래스 구조, 메서드, 필드 등)를 저장하는 공간으로 분리 되면서 

서로 다른 목적을 가진 두영역에서 각각 저장하여 독립적으로 관리될수 있게 되었다. 

힙의 메모리 부족 문제가 메타스페이스에 영향을 미치지않게 됨

( 클래스로딩 이후 클래스 메타데이터가 제대로 저장되지 않으면 해당 클래스를 사용할 수 없다. 

ClassNotFoundException , NoClassDefFoundError 등의 에러가 발생 )

<br>

저장위치 또한 힙 메모리에서 네이티브 메모리를 사용하게되면서 

이전 고정크기였던 메서드 영역이 운영 체제가 제공하는 네이티브 메모리풀에서 동적으로 확장되기 때문에 

메모리 부족 문제를 피할수 있게 되었다. 

(동적으로 클래스를 로딩하는 상황 발생시에도 문제가될 가능성이 줄어들었다. -> 리플렉션,서드파티 라이브러리)

(원래 고정크기였던PermGen와 달리 -XX:MaxMetaspaceSize와같은 옵션으로 효율적으로 제어가능 )


<br>

##### 클래스로딩 및 메타데이터 이외의 관리

클래스 로딩과 관련된 메타데이터는 메타스페이스의 관리로 옮겨갔지만 

(메타스페이스의 역할은 클래스 메타데이터와 관련된 작업으로 제한)

정적 변수나 문자열 풀과 같은 일부 기능은 힙 영역에서 관리하고 있다.

GC 관리 대상에 정적변수, 문자열 풀이 포함되면서 메모리 최적화가 더욱 용이해졌다.

(이전엔 메서드영역에 존재하면서 GC관리대상이 아니였다.)

<br>

#### 2. 프로그램 카운터

<br>

> 현재 실행 중인 명령어의 메모리 주소를 저장하는 레지스터
> 각 스레드 자신만의 프로그램 카운터를 가짐, 독립적으로 실행 흐름을 추적
> 명령어 실행 흐름을 관리 할수 있게 된다.

<br>

###### 컨텍스트 스위칭 시 프로그램 카운터의 동작

스레드 간의 컨텍스트 스위칭이 일어날 때 각 스레드의 프로그램 카운터도 함께 저장되고 복원

###### 시나리오
 
스레드 A의 프로그램 카운터는 컨텍스트로 저장되고 스위칭된 스레드 B는 새로운 프로그램카운터를 가진다. 

다시 스레드 A로 돌아갈때 컨텍스트에 저장된 상태를 복원하여 기존 프로그램 스레드 A 카운터를 참조하여 명령어 흐름을 이어갈 수 있다.

(저장항목 : 프로그램 카운터(PC),레지스터 상태,스택 포인터,프로세서 플래그)

(각 스레드는 독립적인 스택 프레임을 가지고 있으며, 이 스택 프레임 내에서 프로그램 카운터가 실행 중인 명령어의 주소를 추적)

<br>

#### 3. 자바 가상머신 스택 

<br>

> 각 스레드는 자신만의 JVM 스택을 가짐
> JVM에서의 스택 크기는 각 스레드마다 고정된 크기를 가진다.
> 메서드 호출 시마다 새로운 스택 프레임이 생성된다.
> 로컬 변수, 매개변수, 연산 스택을 관리한다.

###### 스택 오버플로우

 JVM 스택에서 메서드 호출로 인한 스택 프레임이 과도하게 쌓여 
 
 더 이상 스택에 새로운 프레임을 추가할 수 없을 때 발생하는 오류이다.

 주요원인 
 1. 재귀 호출(Recursive Call)
 2. 너무 깊은 메서드 호출

 해결방법
1. 재귀 호출 시 조건을 설정,무한 재귀를 방지해야함
2. 메서드 호출 깊이 제한
3. JVM 스택 크기 조정 : -Xss 옵션으로 조정

#### 4. 네이티브 메서드 스택(Native Method Stack)

> 자바 외의 네이티브 코드를 호출할 때 사용하는 메모리 영역
> JNI(Java Native Interface), JNA(Java Native Access)로 네이티브 코드를 호출
> 네이티브 메서드를 호출 시, 스택 프레임이 네이티브 메서드 스택에 생성

같은의미의 스택프레임이지만 데이터의 내용과 저장되는 메모리 영역이 다르다.

핫스팟 JVM(HotSpot JVM)에서는 자바 스택과 네이티브 메서드 스택을 

통합하여 사용하는 경우도 있다(동일한 스택 공간을 사용하는 방식)


#### 5. 힙

> 자바 힙은 동적으로 할당되는 객체와 배열이 저장되는 메모리 영역
> 생성된 객체는 참조를 통해 접근
> 가비지 컬렉션은 힙 영역에서 사용되지 않는 객체들을 관리한다.
> 자바 힙의 크기는 JVM 옵션을 통해 조정

![image](https://github.com/user-attachments/assets/c31f1f11-3677-4d49-92ba-cb9f89cbc852)

- Young Generation :  새로 생성된 객체들이 주로 저장
- Old Generation : 상대적으로 긴 생명주기를 가진 객체들이 저장

- 힙 메모리 크기 조정
 -Xms 옵션으로 초기 힙 크기를 설정하고, -Xmx 옵션으로 최대 힙 크기를 설정

reference
[런타임데이터영역](https://adjh54.tistory.com/280)



