# 2.2

## 런타임 데이터 영역(Java Runtime Data Area)

JVM은 자바 프로그램을 실행하는 동안 **필요한 메모리를 몇 개의 데이터 영역**으로 나누는데, 각각 영역별로 생명주기, 목적에서 차이점이 있다.

![image](https://github.com/user-attachments/assets/b2aef4f0-958a-437d-933b-9f5c2476d66f)

위의 사진은 JVM의 구성 요소를 표현한 것인데, 정리하자면

>- JVM = 클래스 로더 + 런타임 데이터 영역 + 실행 엔진
>- 런타임 데이터 영역 = 메소드 영역 + 힙 영역 + 스택 영역 + 프로그램 카운터 레지스터 + 네이티브 메소드 스택

![image](https://github.com/user-attachments/assets/d93fe54e-9689-4e4c-9cfb-a7bda6242b87)

런타임 데이터 영역은 프로그램 생명주기에서는 클래스 정보와 실행에 필요한 데이터를 저장하고, 객체 생명주기에서는 객체의 생성, 사용, 소멸에 필요한 메모리 영역(힙, 스택 등)을 관리하게 된다. 간단히 정리하자면 **자바 애플리케이션이 실행될 떄 사용되는 데이터들이 저장되는 메모리 공간**이라고 볼 수 있다. 이 중에서 **스레드**가 공유하는 영역은 힙 영역과 메소드 영역이다.

### 1. 프로그램 카운터 레지스터

멀티스레딩에 있어 스레드가 각자의 메소드를 실행하게 될 텐데, 각각의 스레드에게 동시 실행 환경이 보장되어야 한다. 이때, 단위 코어가 한 스레드의 명령어만 실행할 수 있고 교대로 스레드를 번갈아가며 사용되는 방식이어서 **스레드 전환 후, 이전에 실행하다 멈춘 지점을 정확하게 복원할 필요성**이 있다. 이 복원을 위해 스레드 각각에 **프로그램 카운터**가 필요하다.

조금 더 정확히 말하자면 최근에 자바 메소드를 실행 중일 때, 실행 중인 바이트코드 명령어의 주소가 프로그램 카운터에 기록되는 것이며 이것이 기록되는 공간이 **프로그램 카운터 레지스터**다. 만약 실행했던 메소드가 네이티브(C나 C++로 실행)하다면, 해당 명령어의 위치를 알 수 없기 때문에 프로그램 카운터 레지스터에 `undefined` 값을 기록하게 된다.

### 2. 네이티브 메소드 스택

프로그램 카운터 레지스터에서 네이티브 메소드가 실행될 때는 기록이 되지 않으므로 이를 위한 네이티브 메소드 스택이 필요하다. 후술할 스택 영역과 매우 비슷한 역할을 하며 각 스레드 별로 생명주기를 가지게 된다.

### 3. 스택 영역

### 4. 힙 영역

### 5. 메소드 영역

*https://velog.io/@ddangle/Java-%EB%9F%B0%ED%83%80%EC%9E%84-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%98%81%EC%97%ADRuntime-Data-Area%EC%97%90-%EB%8C%80%ED%95%B4*

*https://loosie.tistory.com/847#Runtime_Data_Areas*
