# Chapter 3. 가비지 컬렉터와 메모리 할당 전략

## 1. Garbage Collector : 소개

### 역사
- 1960년 MIT에서 개발된 언어인 리스프(Lisp) 에서 처음 고안 및 사용
- *GC가 처리해야 하는 문제 정의* : Lisp 개발자 존 맥카시(John McCarthy)가 정의
  - 1) GC 대상 : *어떤 메모리를 회수해야 하는가?*
  - 2) GC 시점 : *언제 회수해야 하는가?*
  - 3) GC 방법 : *어떻게 회수해야 하는가?*

### GC는 어디서, 무엇을 하는가?
앞서 우리는 JVM의 메모리 구조에 대해 학습했다. \
그리고 크게 다음의 두 가지로 생각해볼 수 있음을 지금은 알고 있다.
-  *스레드마다 생성되는 메모리 영역*
-  *JVM 실행 시점에 단 한 번 생성되어 복수의 스레드에 의해 공유되는 메모리 영역*
  
스레드마다 생성되는 메모리 영역에 해당하는 스택 영역, PC 레지스터, 네이티브 메서드 스택의 경우 스레드를 위해서 생성되고 해당 스레드에 의해서만 활용되는 영역이다. \
그렇기 때문에 스레드가 종료되면 더 이상 필요가 없어진다는 것을 생각해볼 수 있다.
따라서 어떤 스레드가 종료될 경우, 해당 스레드에게 할당되었던 메모리 영역을 모두 JVM이 회수해도 무방함을 판단할 수 있다.

하지만 객체 인스턴스가 저장되는 ***힙 영역***, 로드된 클래스 코드 및 메서드 코드 데이터와 런타임 상수 풀이 존재하는 ***메서드 영역*** 의 경우 \
무엇을 회수할지, 언제 회수할지 판단하기가 어렵다.

해당 영역이 점유하는 메모리의 크기는 오직 런타임에만 알 수 있고 이때 결정되기 때문이다.
실제로 실행하기 전(컴파일 타임)까지는 실행된 프로그램이 어떤 클래스의 인스턴스를 얼마나 생성할 지 알 수 없기 때문이다.

따라서 이 두 가지 메모리 영역이 점유하고 있는 메모리 공간 할당과 회수를 동적으로 할 수 있는 무언가가 필요한 것이다.
바로 이 '무언가가' ***GC(Garbage Collector)*** 이다.

### GC 메커니즘과 JVM 메모리 할당에 대한 이해 필요성
현재 JVM은 명세 상 내부에 존재하는 메모리 영역의 크기를 동적으로 할당하며, 함께 설계된 GC 알고리즘을 통해 자동으로 불필요한 메모리 점유를 줄여 실행 환경 최적화를 수행한다.

하지만 완벽한 것은 아니기에, 메모리 누수 및 오버 플로우 문제가 종종 발생한다.

따라서 이를 해결하기 위해서는 이처럼 '자동화된 기술'의 메커니즘에 대한 이해를 토대로 적절히 모니터링 및 조율이 필요하다.


### GC 대상 결정 알고리즘 : *참조 카운팅 알고리즘* & *도달 가능성 분석 알고리즘*

우리가 방(메모리) 청소를 하며 무언가를 내다버리기로 마음먹었다고 생각해보자.
이 무언가가 방을 물리적으로 '점유'하고 있기 때문에, 움직일 때 걸리적거렸기 때문이다!
그렇다면 우리는 방 청소를 하며 눈에 닿는 사물의 향후 필요 가능성을 가늠해보게 된다.
> "내가.. 저걸 앞으로.. 쓸 일 있나?" 혹은  "지금 저게,, 나에게 필요한가?"

GC도 마찬가지로 이루어진다.
- 방으로 비유된 메모리 공간을 점유하고 있는 객체 중 당장 필요하지 않거나 앞으로 사용하지 않을 가능성이 높은 것을 선택한다.
- 그것을 버림(메모리 점유 해제)으로써 여유 공간을 확보한다.


여기서 도대체 무엇이 메모리 공간을 점유하고 있는지 다시 상기할 필요가 있다.
실제 메모리 공간을 잡아먹고 있는 것은 객체 인스턴스의 데이터이다.
우리는 이 객체 인스턴스가 저장된 메모리 위치를 JVM의 도움을 받아 변수로부터 *참조* 를 통해 접근하는 것이다.

그렇다면 사용하지도 않는데 메모리 공간을 잡아먹고 있는 데이터들이란 무엇인가?
대표적으로 이는 '참조를 잃어버린 객체 인스턴스 데이터' 이거나, 다른 데이터들에 비해 참조 빈도가 극히 적은 데이터들일 것이다.
이러한 객체들을 '죽은 객체'라고 부르며, 이는 '프로그램 코드에서 어떤 식으로도 더는 사용될 수 없다'라는 것을 의미한다.

이러한 데이터들이 점유한 메모리 공간을 환수하는 작업이 바로 GC인 것이다.

그렇다면 JVM은 어떤 기준으로 '죽은 객체'를 선별하는 것일까? \
아래의 두 알고리즘이 가장 대표적인 방식이다.

#### *참조 카운팅 알고리즘*

##### 작동 방식
> 1. 객체를 가리키는 *참조 카운터(Reference Counter)*를 마련한다.
> 2. 해당 객체를 참조하는 곳이 증가 및 감소할 때마다 이에 맞춰 참조 카운터 값을 증감시킨다.
> 3. 어떤 객체의 참조 카운터가 0이 될 경우, 이는 더 이상 아무도 이 객체를 찾거나 사용하고 있지 않다는 의미가 된다. \
>    따라서 회수한다.

##### 장점
> 심플한 알고리즘이다.

##### 단점
> 단순한 만큼, 실제 사용 상황의 복잡함에 대한 대응이 어렵다.
>   - *순환 참조* 상황에선 *참조 카운팅 알고리즘* 이 객체의 참조 상황을 올바르게 탐지하지 못한다.
> 즉, 모든 상황에서 문제 없이 작동하게 하려면 계산해야 할 요소가 상당히 많아진다.

##### 참조 카운팅 알고리즘의 한계 : 순환 참조 발생 상황
아래의 예시는 어떤 두 객체가 서로 순환 참조 관계를 가지는 상황을 연출한 것이다. \
이때 `System.GC()` 를 호출하여 GC를 수행한다. \
그리고 GC 전후 및 과정을 `-Xlog:gc*` 실행 매개변수를 이용하여 로그를 통해 모니터링 해본다. \
Java는 순환 참조 알고리즘이 아닌 아래의 *도달 가능성 분석 알고리즘* 을 활용하기 때문에 순환참조 객체에 대해서도 GC가 정상작동한다. \
하지만 순환참조 알고리즘의 경우 아래와 같은 상황에서 두 객체의 참조 카운터가 0이 되지 않으므로 절대 GC 대상이 되지 않는다.

```java
/**
 * VM Args : `-Xlog:gc*` -> JDK 8 이하의 경우 `-XX:+PringGCDetails`
 * Subject : "testGC() 메서드 실행 종류 후엔 objA 와 objB가 회수될까?"
 * 
 * @author zzm
 */
 

public class ReferenceCountingGC {
    public Object instance = null;
    private static final int +1MB = 1024 * 1024; // 메모리를 많이 차지 하도록 하여 GC 전후 차이가 두드러지도록 설정
    private byte[] bigSize = new byte[2 * _1MB];

    public static void testGC(){
        // given : 객체 두 개 생성
        ReferenceCountingGC objA = new ReferenceCountingGC();
        ReferenceCountingGC objB = new ReferenceCountingGC();

        // when : 두 객체 간 순환 참조 상태 설정 -> 이후 objA, objB 참조 해제
        objA.instance = objB;
        objB.instance = objA;

        objA = null;
        objB = null;

        // then : 두 객체는 GC 되고, 이들이 점유하던 메모리 공간은 JVM에게 반환된다.
        System.gc();
        
    }

    public static void main(String[] args) {
        testGC();
    }

} 

```

#### *도달 가능성 분석 알고리즘*
이 알고리즘이 바로 많은 JVM에서 채택하고 있는 알고리즘이다.

##### 작동 방식
> 1. *GC 루트* 라는 객체 집합이 존재한다.
> 2. 이 *GC 루트* 내의 객체를 하나의 노드로 생각하고 여기서 출발하여 *참조* 로 도달 가능한 모든 객체를 탐색한다.
> 3. *GC 루트* 집합 내의 모든 객체로부터 탐색이 완료된 후에도 탐색되지 않은 객체를 '죽은 객체'로 간주한다.

##### *GC 루트* 집합 조건 : `해당 객체에 대한 참조 및 사용이 최소 1회 보장되는 것`
- 가상 머신 스택(엄밀히 말하면 스택 프레임의 지역 변수 테이블)에서 참조하는 객체
- 메서드 영역에서 클래스가 정적 필드로 참조하는 객체
  - `static` 필드는 해당 객체의 인스턴스가 모두 참조하는 영역이므로 처음 사용되기 전에 반드시 초기화되어야 한다.
  - 따라서 `static`는 클래스 로딩 이후 초기화 된다. 즉, 최소 한 번은 참조가 이루어지는 것이다.
- 메서드 영역에서 상수로 참조되는 객체
- 네이티브 메서드 스택에서 `JNI`가 참조하는 객체
- 자바 가상 머신 내부에서 쓰이는 참조
  - 기본 데이터 타입에 해당하는 `Class` 객체
  - 일부 상주 예외 객체 : `NullPointerException`, `OutOfMemoryError` 등
  - 시스템 클래스 로더
- 동기화 락(`synchronized` 키워드 등)으로 잠겨 있는 모든 객체 : 어떤 스레드에서 사용 중이거나 사용할 확률이 높게 점쳐지는 객체
- 자바 가상 머신 내부 상황 반영하는 `JMXBean` : JVMTI(JVM Tool Interface)에 등록된 콜백, 로컬 코드 캐시 등

이 외에도 가비지 컬렉터 종류 및 회수 중인 메모리 영역 종류에 따라 다른 객체들도 '임시로' 추가될 수 있다.

또한 이 때 *GC 루트* 집합 내엔 주로 Heap 영역 내 존재하는 데이터를 참조하는 객체가 포함되지만, Heap 영역 밖에 존재하는 객체 또한 존재할 수 있다. \
이는 Heap 영역 내의 객체가 연결된 참조를 통해 다른 영역의 객체를 참조하고 있을 수 있기 때문이다.

<br>

> ***JVMTI(JVM Tool Interface)***
> 
> 프로그램에 대한 모니터링, 디버깅, 프로파일링을 가능하게 하기 위해 JVM에서 제공하는 네이티브 프로그래밍 인터페이스


## GC와 참조

### 도달 불가능한 객체는 모두 수거되는가?
그렇지 않다.
JVM은 어떤 객체의 GC 대상 여부를 보다 엄밀하게 판단하기 위해 두 번의 표시( *marking* )을 수행한다.

JVM은 *도달 가능성 분석* 직후 두 번의 표시 작업을 수행한다.
1. 첫 번째 표시
 - GC 루트와 연결된 참조 사슬을 발견하지 못한 객체 대상 첫 번째 표시 수행

2. 두 번째 표시
 - 첫 번째 표시가 시행된 객체 대상으로 *필터링* 을 수행한다.
 - 바로 이 필터링 조건 => ***`finalize()` 메서드를 호출해야 하는 객체인지 확인하는 것***

### 참조

#### JDK 1.2 이전에서의 정의
> "참조 타입 데이터에 <u>저장된 값이 다른 메모리 조각의 시작 주소를 뜻한다면</u>, \
> 이 참조 데이데가 해당 메모리 조각이나 객체를 *참조* 한다고 말한다."

- 이 정의는 상당히 좁은 의미의 정의
- 이 정의를 따라 객체의 상태를 구분한다면 "참조 상태" 와 "비참조 상태" 두 가지로만 구분이 된다.

하지만 실제로 보다 정교한 시스템(JVM)을 설계하기 위해 고민을 하다보면 객체의 상태를 위의 두 가지로만 조망하는 것이 충분하지 않음을 알게 된다.
- 가령, "메모리가 여유롭다면 그냥 두지만, 모자랄 경우 그때 회수하는 객체"와 같은 상태도 존재하는 편이 정교한 시스템 설계에 필요한 것이다.

따라서 보다 세밀하게 구분하여 JDK 1.2부터 참조를 네 가지로 구분하여 정의하기 시작한다.

#### JDK 1.2 부터의 정의
##### 강한 참조(Strong Reference)
- 위에서 언급한 전통적인 정의의 참조
- 프로그램 코드 상에서 선언된 참조
  - ex. `Object obj = new Object()`
- 강한 참조 관계가 남아있는 객체는 **GC에서 절대로 회수하지 않는다**.

##### 부드러운 참조(Soft Reference)
- 유용하지만 필수는 아닌 객체
- 이 참조에 해당하는 객체는 메모리 오버 플로우 직전, '두 번째 회수 시 회수할 목록'에 추가된다.
- 두 번째 회수 후에도 메모리가 모자랄 경우, 이 목록에 있는 *부드러운 참조 객체* 를 회수하여 메모리 확보한다.

##### 약한 참조(Weak Reference)
- 부드러운 참조와 유사하나, 보다 연결 강도가 약한 참조.
- 약한 참조만 남은 객체 -> 다음 번 GC 때까지만 살아있다.
  - 즉, 다음 GC 때는 반드시 회수할 대상으로 이미 정해진 것.
- GC가 동작하기 시작하면, 메모리가 여유롭더라도 약한 참조 개체는 무조건 회수.
- JDK 1.2 부터 도입된 `WeakReference` 클래스가 구현한다.

##### 유령참조(Phantom Reference)
- 가장 약한 연결 강도를 갖는 참조
- 객체 수명에 아무런 영향을 주지 않는다. -> 어떤 객체가 유령 참조가 100개라고 하더라도 더 오래 살아있거나, 더 빨리 죽지 않는다는 것.
- 그렇다면 왜 이걸 굳이 사용하는가? -> 객체 회수시 '알림'을 받기 위함.
- 마찬가지로 JDK 1.2 부터 도입되었으며, `PhantomReference` 로 구현되어 있다.

> ***파이널 참조*** : `finalize()`
> 1. 정의
>>   - JDK 내부적으로 사용되는 참조 유형
>>   - 약한 참조와 유령 참조 사이의 강도
>>   - 파이널 참조 객체란? -> `finialize()` 메서드가 정의된 모든 객체.
>>   - 어떻게 처리되는가?
>>       - `finalize()` 메서드가 정의된 객체는 자동으로 F-Queue(파이널 참조 객체 대기열)에 등록된다.
>>       - 이 객체에 대한 강한 참조, 부드러운 참조, 약한 참조가 모두 없어질 경우 `finalize()` 메서드가 호출된다.
>>   - 하지만, 사용하지 않을 것이 추천되는 키워드.
>>     - 실행 비용이 높다.
>>     - 불확실성이 높다 -> 어떤 파이널 참조 객체부터 호출되는지 확실하지 않다. 이는 공유 변수 존재 시 꼬일 수 있는 가능성을 주는 것.
>
>
> 2. `finalize()`
>> - 무엇인가?
>>   - `java.lang.Object` 에 선언된 method.
>> - 뭘 하는가?
>>   - 해당 객체가 점유한 메모리가 JVM에 의해 회수되기 전, 자신이 가진/사용 중인 자원을 '정리'하는 로직이 구현하는 것.
>>   - 그리고 이 로직이 마지막에 호출됨으로서 해당 객체가 점유한 리소스가 모두 반환이 이루어지는 것.

### 메서드 영역 대상 GC
> *주석*
> 해당 책에서는 *타입* 언로딩과 *클래스* 언로딩이 혼용되고 있다. \
> 결론부터 말하자면 여기서 타입과 클래스 모두 '클래스'를 지칭한다고 이해해도 무방하다. \
> Type의 경우 정의 상 '행동'과 '상태'를 갖는 객체에 대한 정의를 의미한다. \
> Java 에서의 `Class` 는 이 Type을 표현하는 방식이

JVM 명세 상 메서드 영역에 대한 GC는 강제되지 않는다. \
- 실제로 JDK 11에 탑재되었던 ZGC 컬렉터는 클래스 언로딩(프로그램 실행 시 메서드 영역에 올린 클래스 코드 데이터를 다시  내리는 것)을 지원하지 않았다.

이는, 메서드 영역 대상 GC의 '비용 대비 효율'이 떨어지기 때문이다.
- 클래스 언로딩의 필요 빈도가 높지 않다.
- 하지만 요구되는 실행 비용이 높다.
  - 어떤 클래스를 내리기 이전에, 해당 클래스 필드를 참조하는 객체가 있는지 전수조사를 해야한다.
  - 클래스 언로딩 시 실행 중인 JVM의 내부 구조 재조정이 필요하다.(ex. 메모리 영역 크기 조정 등)
- 그럼에도 불구하고 GC 시 회수하는 메모리의 크기가 절대로 크지 않다.
  - 일반적으로, 클래스 메타데이터는 Heap 영역에 존재하는 객체 인스턴스에 비해 메모리 공간을 훨씬 덜 소비하기 때문이다!

그럼에도 불구하고 필요에 따라 수행될 경우 크게 두 가지를 회수하도록 구현되는 것이 일반적이다.
1. 더 이상 사용되지 않는 상수
2. 더 이상 사용되지 않는 클래스(엄밀히 말하자면 클래스 메타데이터)
   - 아래의 세 가지 부분에 대한 검증을 통해 '더 이상 사용되지 않는 클래스' 여부를 판별한다.
     - 1. 이 클래스의 인스턴스가 모두 회수되었음.
     - 2. 이 클래스를 읽어 들인 클래스 로더가 회수 되었음.
     - 3. 이 클래스에 해당하는 `java.lang.Class` 객체를 참조하는 곳이 없으며, Reflection을 이용해 해당 클래스의 메서드를 이용하는 곳도 전혀 없음.

## GC 알고리즘






