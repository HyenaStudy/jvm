## 3.1 들어가며
- 메모리 오버플로우와 누수 문제 해결을 위해 가비지 컬렉션과 메모리 할당 방식을 이해해야 함
- 자바 힙과 메서드 영역은 같은 인터페이스라도, 구현한 클래스마다 메모리 요구량이 다름<br>
  -> 어떤 객체를 얼마나 만들지는 런타임에서만 알 수 있음<br>
  -> 해당 메모리 영역에서의 할당과 회수는 동적으로 이루어짐
<br><br>

## 3.2 대상이 죽었는가??
> 가비지 컬렉터가 힙을 청소하려면 어떤 객체가 살아있고 죽었는지 판단해야 함

### 3.2.1 참조 카운팅 알고리즘
1. 객체를 참조하는 곳이 생기면 카운터 값 +1
2. 참조하는 곳이 사라지면 카운터 값 -1
3. 카운터 값이 0이면 더는 사용되지 않는 객체로 간주하여 회수<br>
   -> 하지만 JVM에서는 참조 카운팅 알고리즘을 사용하지 않음
<br>

**허점**
- 참조 카운팅 알고리즘에 따르면, 객체가 서로를 참조(순환참조)할 경우 참조를 해제해도 카운터 값이 0이 되지 않아 회수를 못함
- 하지만 자바에서는 `-Xlog:gc`나 `System.gc()`로 이러한 문제를 해결
<br><br>

### 3.2.2 도달 가능성 분석 알고리즘
- 자바, C# 등 주류 프로그래밍 언어에서 객체 생사 판단에 사용
- **작동 원리**  
  - GC 루트 객체를 시작 노드 집합으로 설정
  - 참조하는 다른 객체들을 새 노드로 추가하며 연결 경로 탐색
  - 객체와 GC 루트 사이에 참조 체인(간선)이 없으면 해당 객체는 회수 대상
- **유의점**
  - 메모리 영역들이 완전히 격리되거나 닫혀 있지 않을 수 있음.  
  - 한 객체가 다른 영역의 객체를 참조할 수 있으므로, **연관된 영역의 객체**도 GC 루트 집합에 포함시켜야 정확한 도달 가능성 분석 가능
<br><br>

### 3.2.3 다시 참조 이야기로
**참조의 4가지 종류**
1. 강한 참조(strong reference)
  - 가장 전통적인 참조 방식
  - 강한 참조가 남아 있는 객체는 가비지 컬렉터가 절대 회수하지 않음
  - ex) Object obj = new Object()
<br>

2. 부드러운 참조(soft reference)
  - 유용하지만 필수는 아닌 객체
  - 메모리가 부족할 때만 회수 대상
  - ex) SoftReference<MyObject> softRef = new SoftReference<>(new MyObject());
<br>

3. 약한 참조(weak reference)
  - 부드러운 참조와 비슷하지만 연결 강도가 약함
  - 다음번 가비지 컬렉션에서 회수 대상(메모리가 넉넉해도 회수)
  - ex) WeakReference<MyObject> weakRef = new WeakReference<>(new MyObject());
<br>

4. 유령 참조(phantom reference)
  - 객체의 수명에 영향을 주지 않으며, 객체 인스턴스를 가져올 수 없음
  - 객체가 회수될 때 알림을 받는 데 사용
  - **사용 이유**
    - 객체 회수 시 정리 작업 수행을 위해
    - 대규모 애플리케이션에서 네이티브 리소스(예: 파일 핸들, 네트워크 소켓) 해제를 확인하는 데 활용
<br>

+ 파이널 참조(final Reference)
  - 약한 참조와 유령 참조 사이
  - `finalize()` 메서드를 구현한 객체는 파이널 참조 대상이 되어 별도 대기열에 등록
  - 강한, 부드러운, 약한 참조가 모두 없어지면 `finalize()` 메서드 호출
<br><br>

### 3.2.4 살았나 죽었나?
- 도달 가능성 분석 알고리즘에서 '도달 불가능 객체'를 반드시 회수하진 않음
- 유예 단계를 거치며, 2번의 표시 과정 필요
<br>

1. 첫 번째 표시
   - GC 루트와 연결된 참조 체인을 찾지 못하면 첫 번째로 표시 후 필터링
2. 두 번째 표시
  - `finalize()`가 필요 없거나 이미 호출된 객체는 바로 회수
  - `finalize()` 실행 필요 객체는 **F-큐 대기열**에 추가해 종료자 스레드가 실행
    - 실행만 시키고 종료를 기다리지 않음
    - 오래 걸리거나 무한 루프에 빠지면 가비지 컬렉션 시스템 전체 비정상 종료 위험
* finalize()는 JDK9부터 폐기 대상. try-finally 등 다른 방법으로 처리 가능
<br><br>

### 3.2.5 메서드 영역 회수하기
- 메서드 영역 가비지 컬렉션은 대체로 비용 효율이 좋지 않다
- 더 이상 사용되지 않는 상수와 클래스 회수
<br>

**상수 회수하는 방법**
- 조건 : 상수 풀에 저장된 문자열이 시스템 내에서 참조하는 객체나 코드가 전혀 없는 상태
- 작동 방식 : 가비지 컬렉터가 해당 문자열을 상수 풀에서 삭제.
<br>

**더 이상 쓰이지 않는 클래스 판단 조건**
1. 자바 힙에 해당 클래스와 하위 클래스 인스턴스가 모두 회수된 상태
2. 클래스를 로드한 클래스 로더가 회수된 상태 -> 세심하게 설계된 대안 클래스 로더없이는 충족하기 어려움
3. java.lang.Class 객체를 참조하거나 리플렉션 기능으로 해당 클래스의 메서드를 호출하는 곳이 전혀 없는 상태<br>
-> 3가지 모두 충족하면 회수하도록 '허용'
<br><br>

## 3.3 가비지 컬렉션 알고리즘
### 3.3.1 세대 단위 컬렉션 이론
1. 약한 세대 가설 : 대다수 객체는 일찍 죽는다
2. 강한 세대 가설 : 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 오래 살 가능성이 크다
3. 세대 간 참조 가설: 세대 간 참조는 같은 세대 안에서의 참조보다 훨씬 적다.  
<br>

- 자바 힙을 신세대와 구세대로 나눠, 객체 생존 횟수에 따라 다른 영역에 할당
- 신세대는 금방 죽을 객체를 몰아넣고, 살아남은 소수의 객체만 유지해 적은 비용으로 대량의 메모리 확보
- 세대 간 참조는 드물어서 기억 집합을 사용해 효율적으로 관리
<br><br>

**GC 방식 개념 정리**
- 부분 GC : 특정 영역만 회수
  - 마이너 GC : 신세대만 회수
  - 메이저 GC : 구세대 회수
  - 혼합 GC : 신세대 + 구세대 일부 회수
- 전체 GC : 모든 영역 회수
<br><br>

### 3.3.2 마크-스윕 알고리즘
- 회수할 객체를 표시(mark)하고 표시된 객체를 쓸어담는(sweep) 방식
- **단점**
  - 객체가 많을수록 작업량이 증가해 작업 효율 감소
  - 메모리 파편화 발생 -> 프로그램이 큰 객체를 만들 때 연속된 메모리를 찾기 힘들어 추가 가비지 컬렉션 유발
<br><br>

### 3.3.3 마크-카피 알고리즘
- 가용 메모리를 똑같은 크기의 두 블록으로 나눠 한 블록만 사용
- 한쪽이 꽉 차면 살아남은 객체만 다른 블록에 복사하고 기존 블록 청소
- 복사할 때 차곡차곡 쌓이면서 메모리 파편화 문제 해결
- **단점**
  - 가용 메모리를 절반으로 줄여 낭비가 심하다
  - 신세대 객체 중 98퍼가 첫번째 가비지 컬렉션에서 죽어서 신세대용 메모리 영역을 1:1로 나눌 필요 없음
<br><br>

### 3.3.4 마크-컴팩트 알고리즘
- 생존한 객체를 메모리 한쪽 끝에 모은 후 나머지 공간을 한꺼번에 비움
- 구세대는 생존 객체가 많아 객체 이동과 참조 갱신 비용이 높음
- 근데 이동시키지 않으면 힙 파편화 발생 -> 객체를 이동시키면 회수가 복잡, 안하면 할당이 복잡
- **해결책** : 파편화 없는 할당 연결 리스트로 메모리 할당 문제 해결
