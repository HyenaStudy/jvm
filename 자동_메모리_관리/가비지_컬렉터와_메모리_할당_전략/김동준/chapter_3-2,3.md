가비지 컬렉터가 힙에 저장된 객체를 정소하려면 죽은 객체를 판단해야 한다. 즉, 어떤 식으로도 더는 사용될 수 없는 객체를 찾아야 한다. 개념 위주로 정리하되, 알고리즘과 관련해서는 요건에 해당하는 객체인지를 판별하는 알고리즘들을 이해하고 필요시 커스터마이징하면서 직접 테스트를 통해 이해할 예정.

## 알고리즘

### 1. 참조 카운팅 알고리즘

참조 카운팅 알고리즘은 가장 단순하게 구현된 알고리즘이다. 이 알고리즘은 **어떤 다른 객체도 참조하지 않는 객체**를 더 이상 필요없는 객체로 여기고 이를 가비지라 부른다. 참조 개수를 카운팅해서 참조가 하나도 없으면(0이면) 가비지로 판단한다. 즉, 메모리 주소가 참조될 때마다 카운트를 1 증가시키고, 참조를 끊을 땐 1 감소시킴으로써 카운트를 체크했을 때 0이면 메모리를 해제하는 방식이다.

다만 이 알고리즘은 **순환 참조** 문제를 해결하지 못한다. 아래의 코드를 GC 로그가 뜨도록 파라미터를 부여해서 실행해본다.
```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int MB = 1_024 * 1_024;
    private byte[] bigSize = new byte[2 * MB];

    public static void main(String[] args) {
        test();
    }

    public static void test() {
        ReferenceCountingGC a = new ReferenceCountingGC();
        ReferenceCountingGC b = new ReferenceCountingGC();

        // 상호 참조
        a.instance = b;
        b.instance = a;

        a = null; // a 변수 더 이상 아무 것도 참조 x
        b = null; // b 변수 더 이상 아무 것도 참조 x

        /**
         * 변수가 가리키는 방향만 달라졌을 뿐, 기존 a, b에 할당됐던 객체는 여전히 남아있음
         */

        // 가비지 컬렉터 수행
        /**
         * 참조 카운팅 알고리즘대로라면 사실 동작할 수가 없음. 여전히 객체 2개는 살아있고 여전히 상호 참조 중이므로 
         */
        System.gc();
    }
}
```
<img width="60%" alt="스크린샷 2024-12-13 오후 9 00 45" src="https://github.com/user-attachments/assets/e42a1877-be1a-43bc-9ad9-5c634e37ed2a" />

보면 확인되지만 애시당초 참조 카운팅 알고리즘을 사용하는 옵션 자체를 제공하지 않는다. 왜냐하면 코드에서도 확인할 수 있듯, 상호 참조가 남아있는 객체가 잔존한 이상 참조 카운팅 알고리즘이 동작할 수 없다.

즉, 참조 카운팅 알고리즘은 GC를 수행하기 위한 알고리즘이 될 수 없다.

### 2. 도달 가능성 분석 알고리즘

통상 객체의 생사 판단에는 **루트 객체로부터 거슬러 올라가 닿을 수 있는가**를 기준으로 판단하게 된다. 여기서 쓰이는 알고리즘이 그래프에서 길 찾기를 할 때 주로 쓰이는 **BFS** 혹은 **DFS**가 주로 쓰인다. 

#### 마크 스윕

#### 마크 카피

#### 마크 컴팩트
