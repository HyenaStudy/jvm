가비지 컬렉터가 힙에 저장된 객체를 정소하려면 죽은 객체를 판단해야 한다. 즉, 어떤 식으로도 더는 사용될 수 없는 객체를 찾아야 한다. 개념 위주로 정리하되, 알고리즘과 관련해서는 요건에 해당하는 객체인지를 판별하는 알고리즘들을 이해하고 필요시 커스터마이징하면서 직접 테스트를 통해 이해할 예정.

## 서론

참고로 GC는 자바만의 특징이 아닌, 다른 프로그래밍 언어(자바스크립트, 파이썬 등)도 가지고 있는 특징이다. 또한 후술할 알고리즘들의 베이스 역시 다른 언어들의 GC에서도 똑같이 통용되는 편이다. 그럼에도 불구하고 자바, 코틀린 즉 JVM의 GC에서 도드라지는 특징들은 아래와 같다.

1. 세대별 가비지 컬렉션을 통해 객체 수명에 맞춘 효율적 메모리 관리
2. 다양한 GC 알고리즘 제공(Serial, Parallel, G1, ZGC 등)으로 애플리케이션 요구사항에 맞는 선택 가능
3. Stop-The-World 시간 최소화를 목표로 한 동시성 GC의 발전
4. GC 튜닝 및 핫스팟 최적화를 통해 동적 성능 개선

위의 특징들을 바탕으로 다양한 GC 알고리즘 및 동작 원리를 중점적으로 공부할 예정.

## 알고리즘 개념

### 1. 참조 카운팅 알고리즘

참조 카운팅 알고리즘은 가장 단순하게 구현된 알고리즘이다. 이 알고리즘은 **어떤 다른 객체도 참조하지 않는 객체**를 더 이상 필요없는 객체로 여기고 이를 가비지라 부른다. 참조 개수를 카운팅해서 참조가 하나도 없으면(0이면) 가비지로 판단한다. 즉, 메모리 주소가 참조될 때마다 카운트를 1 증가시키고, 참조를 끊을 땐 1 감소시킴으로써 카운트를 체크했을 때 0이면 메모리를 해제하는 방식이다.

다만 이 알고리즘은 **순환 참조** 문제를 해결하지 못한다. 아래의 코드를 GC 로그가 뜨도록 파라미터를 부여해서 실행해본다.
```java
public class ReferenceCountingGC {
    public Object instance = null;
    private static final int MB = 1_024 * 1_024;
    private byte[] bigSize = new byte[2 * MB];

    public static void main(String[] args) {
        test();
    }

    public static void test() {
        ReferenceCountingGC a = new ReferenceCountingGC();
        ReferenceCountingGC b = new ReferenceCountingGC();

        // 상호 참조
        a.instance = b;
        b.instance = a;

        a = null; // a 변수 더 이상 아무 것도 참조 x
        b = null; // b 변수 더 이상 아무 것도 참조 x

        /**
         * 변수가 가리키는 방향만 달라졌을 뿐, 기존 a, b에 할당됐던 객체는 여전히 남아있음
         */

        // 가비지 컬렉터 수행
        /**
         * 참조 카운팅 알고리즘대로라면 사실 동작할 수가 없음. 여전히 객체 2개는 살아있고 여전히 상호 참조 중이므로 
         */
        System.gc();
    }
}
```
<img width="60%" alt="스크린샷 2024-12-13 오후 9 00 45" src="https://github.com/user-attachments/assets/e42a1877-be1a-43bc-9ad9-5c634e37ed2a" />

보면 확인되지만 애시당초 참조 카운팅 알고리즘을 사용하는 옵션 자체를 제공하지 않는다. 왜냐하면 코드에서도 확인할 수 있듯, 상호 참조가 남아있는 객체가 잔존한 이상 참조 카운팅 알고리즘이 동작할 수 없다.

즉, 참조 카운팅 알고리즘은 GC를 수행하기 위한 알고리즘이 될 수 없다.

### 2. 도달 가능성 분석 알고리즘

통상 객체의 생사 판단에는 **루트 객체로부터 거슬러 올라가 닿을 수 있는가**를 기준으로 판단하게 된다. 여기서 쓰이는 알고리즘이 그래프에서 길 찾기를 할 때 주로 쓰이는 **BFS** 혹은 **DFS**가 주로 쓰인다.

<img width="70%" src="https://github.com/user-attachments/assets/909fd9e1-da9a-4e3b-9b3c-217654402564" />

그 중에서도 주로 많이 쓰이는 건 **DFS**다. 길찾기 기반이며 시간 복잡도가 `O(n)`으로 같지만, 메모리 효율성이 더 뛰어나다. 그 이유는 객체의 참조 구조는 보통 그래프에서도 **유사 트리 구조**를 기반으로 형성되는데, DFS는 너비와 상관없이 루트 노드로부터 추적하는 현재 경로상의 노드만을 기억하면 되는 반면, BFS는 현재 위치한 깊이의 전체 너비의 노드를 기억해야 하기 때문이다. 

또한, 구조 자체가 객체의 참조를 재귀적으로 호출해서 파악하는 방식이므로 재귀를 기반으로 구현한 DFS가 직관적으로 적용되기 쉬운 편이다. 위의 과정이 곧 밑에서 나오는 마크 시리즈의 **마킹 단계**에 적용되는 알고리즘이며 이 과정을 통해 도달 가능성을 분석하고 도달이 불가능한 객체는 곧 GC의 대상이 된다.

#### (1) 마크 스윕(Mark & Sweep)

<img width="70%" alt="스크린샷 2024-12-16 오전 12 02 46" src="https://github.com/user-attachments/assets/eacf23b5-0c38-4d8d-b104-fe22f8750c29" />


마킹 이후, 스윕 단계에서는 단순하게 비활성 객체를 해제하게 된다. 즉 마킹 단계에서 이미 도달 가능성에 따른 생사여부가 결정됐기 때문에 죽었다고 판정된 객체를 단순히 제거되기 때문에 특별한 기법이 요구되진 않는다. 그렇기 때문에 후술할 다른 알고리즘들에 비해 구현이 상당히 간단하다. 

이 과정은 Young Gen, Old Gen 모두에서 이뤄지며 각자의 기법은 다르지만 공통적으로 죽은 판정을 받은 객체들이 제거된다. 다만 이 과정에서 제거된 객체의 자리에 남는 빈 공간이 낭비되면서 큰 규모의 메모리 공간이 확보되지 못하는 이른바 **메모리 단편화** 이슈가 발생할 수 있어서 후술할 카피 단계와 컴팩트 단계가 같이 쓰이는 편이다.

#### (2) 마크 카피(Mark & Copy)

<img width="70%" alt="스크린샷 2024-12-16 오전 12 03 49" src="https://github.com/user-attachments/assets/99b919a7-3801-4591-913f-bdb03d29ab09" />

객체가 존재하는 힙 공간을 **From** 공간과 **To** 공간으로 나눈다. From 공간에서 객체 할당 이후, GC가 작동해서 마킹이 마무리되면 죽은 객체를 처리하고 살아있는 객체를 **To** 공간으로 복제하게 된다. 이로써 From 공간은 텅비게 되므로 새로운 메모리 할당 영역으로 활용이 가능해진다. 복사된 곳에서는 자연스럽게 압축된 것마냥 배치되기 때문에 메모리 단편화 이슈를 해결할 수 있다.

다만, 이 방법은 결국 메모리 가용 공간이 절반으로 줄어드는(항시 To 공간을 마련해야 하므로) 단점이 발생된다. 또한 복사라는 것은 결국 객체의 이동이기 때문에 그 과정에서 드는 리소스 비용 역시 고려해야 된다. 이런 특성 때문에 객체 밀도가 낮은 경우에 효율성을 발휘할 수 있는 GC 기법이라 할 수 있다.

#### (3) 마크 컴팩트(Mark & Compact)

<img width="70%" alt="스크린샷 2024-12-16 오전 12 41 32" src="https://github.com/user-attachments/assets/d542aeb2-9fc2-4ab6-beb0-cf0724bd7f08" />

마크 단계에서 죽은 객체를 제거하고 생존 판정을 받은 남은 객체들을 메모리의 한쪽 끝으로 밀어붙이는, 이른바 **압축(Compact)** 과정을 거쳐서 메모리 연속 공간을 확보하여 단편화 이슈를 해결한다. 설명이 단순하지만, 마크 카피에 비해 구현도가 복잡하고 객체 이동 비용이 마크 카피에 비해 상대적으로 더 비싼 편에 속한다. 마크 카피의 경우는 참조 주소를 업데이트하는 방식으로 복사, 즉 **순간이동**처럼 이뤄지지만, 마크 컴팩트는 실제로 객체를 **움직여 이동**하는 방식으로 압축이 이뤄지기 때문이다.

## 실제 적용례

### 1. G1 GC (Garbage First)

### 2. Serial GC (직렬 GC)

### 3. Parellel GC (병렬 GC)

### 4. CMS GC (Concurrent Mark - Sweep)

### 5. ZGC

---

*참조*<br />
*https://abiasforaction.net/understanding-jvm-garbage-collection-part-1/*<br />
*https://abiasforaction.net/understanding-jvm-garbage-collection-part-2/*<br />
*https://velog.io/@mirrorkyh/GC-%EC%A2%85%EB%A5%98%EC%99%80-%ED%8A%B9%EC%A7%95*<br />
*https://www.baeldung.com/jvm-garbage-collectors*
