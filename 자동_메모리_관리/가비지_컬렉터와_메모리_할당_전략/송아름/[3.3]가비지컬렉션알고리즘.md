## Garbage Collection

<br>

가비지 컬렉터는 JVM 에만 국한된 개념은아니다.

수동으로 메모리를 할당하고 해제해야했던 초기 언어에선 다양한 문제들이 생겼고,

여러 언어에서 메모리 관리 자동화를위해 가비지컬렉터를 도입하게 되었다.  

그럼에도 GC = JVM 이라는 인식은 JVM에서 GC의 성공적인 초기도입사례로 

GC 개념이 대중화되고 표준을 제시하게 되어서인것 같다.

( 안정적이고 성능 최적화된 언어로의 발전에 핵심요소로 작용해 왔다고한다 )

<br>


> JVM은 GC의 세밀한 설정이 가능하다
>
>  
> 1. GC 알고리즘선택
> 2. 힙 크기 조정: -Xms, -Xmx
> 3. GC 스레드 수 조정: -XX:ParallelGCThreads(병렬스레)
> 4. G1 GC 설정: -XX:MaxGCPauseMillis
> 5. Young, Old 영역 비율조절 : -XX:NewRatio

<br>

###### 설정방법 1 (개발환경)
```bash
# 1. IDE 설정
# Run Configuration
# eclipse.ini (eclipse만)

# 2. 실행 명령어 (명령줄에서 직접 JVM 옵션 설정)
java -Xms512m -Xmx1024m -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=4 -XX:NewRatio=2 -jar MyApp.jar

# 3. shell script/ yml,ini 외부설정파일 활용
# start-server.sh
#!/bin/bash
# 정의
JAVA_OPTS="-Xms512m -Xmx1024m -XX:MaxGCPauseMillis=200 -XX:ParallelGCThreads=4 -XX:NewRatio=2"
# 실행
java $JAVA_OPTS -jar MyApp.jar

# config.ini 또는 application.yml
```
###### 설정방법 2 (운영)
```bash
# 1. 서버 환경 변수 설정 , 배포 스크립트에서 사용
export JAVA_OPTS="-Xms512m -Xmx1024m"
java $JAVA_OPTS -jar MyApp.jar

# Dockerfile /  docker-compose.yml / CI/CD 스크립트에 포함

# 클라우드 사용 시 해당 클라우드에서 제공하는 설정  매개변수로 관리
```
###### JVM 초기화와 옵션 적용 확인 (jcmd, jstat 모니터링)
```bash
# 1. 실행 중 옵션 확인
jcmd <PID> VM.flags

# 2. 힙 메모리 상태 확인
jcmd <PID> GC.heap_info

# 3. 가비지 컬렉션 실행 빈도, 메모리 상태 확인
jstat -gc <PID>
```

<br><br>

## 메모리할당전략과 Garbage Collection

<br>

#### 메모리 최적화에 Garbage Collection이 중요한 이유

<br>

스택(LIFO)등 힙 이외의 메모리는 비교적 명확하고 간단한 구조로 관리됨

힙(Heap)은 실행중에 동적으로 메모리 요구량을 계산하고 할당되어, 관리하기가 복잡함.

객체지향언어에서 객체가 메모리 관리의 핵심 단위가 되면서 객체의 생명주기(참조여부)를 기반으로 메모리를 관리, 

힙 메모리의 최적화가 필요했다.

자동으로 처리한다고 해도 객체 생명주기가 명확하지않아 제어하기 힘들다.

<br>

> 자동 메모리 해제 (참조되지않는 객체 정리)
> 
> 단편화 최소화 (Compaction으로 사용가능 공간을 효율적으로 재배치)
> 
> 안정성

###### 참고 )) Garbage Collection은 기본적으로cpu 개수만큼 할당된다 (스레드 사용)

<br><br>

## Garbage Collector 동작 원리

<br>

#### 객체 참조 여부 판단

###### 생성된 객체가 힙에 저장된 이후 해당 객체가 참조되지 않으면 제거 해야한다

<br>

> 1. 참조 카운팅
>
 각 객체는 참조되는 카운터를 가짐 , 0 이면 제거 **(순환참조 해결안됨)**
 (파이썬?)

<br>
 
>   
> 2. 루트 객체 탐색
> 
 루트 객체 (항상 참조 가능한 객체)에서 **참조체인**이 이어지지 않는 객체 제거 **(순환참조 해결)**

![image](https://github.com/user-attachments/assets/e84276c7-d920-4507-81a5-750c8db0c74c)


<br>

#### GC 알고리즘
###### 루트 객체 탐색을 기본원리로 STW현상을 최소화하는 방향으로 발전했다. 
>  Stop-The-World(STW)
>
> GC를 실행하는 쓰레드를 제외한 나머지 쓰레드는 작업을 멈춘다
> 
> GC가 너무 자주실행되면 성능하락의 문제가 될수 있다.
>

<br>

> 객체의 참조 여부 판단, 메모리 해제, 단편화 제거
> 
> 현재 GC 알고리즘(G1, ZGC)은 대규모 메모리 사용과 저지연 애플리케이션에 최적화되어 있음

<br><br>

---- 물리적으로 고정된 Young / Old 영역으로 나누어 사용 ----

#### Mark-and-Sweep (Mark-Copy,Mark-Compact)
![image](https://github.com/user-attachments/assets/205b8d30-6f77-46bd-99aa-01ad7bd95826)

Mark : GC Roots에서 시작하여 참조 가능한 객체를 식별(Mark).

Sweep : 마크되지 않은 객체는 제거(Sweep).

Compact : Mark,Sweep으로 끝나면 메모리 단편화가 심해져 Copy나 Compact로 사용 메모리를 모음

<br>

#### Serial GC

CPU 코어가 1일때 가장 단순한 GC, STW이 길다.

<br>

#### Parallel GC (Java 8 default)

Young 영역 Minor GC 멀티 쓰레드수행 (Old 영역은 싱글 쓰레드)

<br>

#### CMS GC (Concurrent Mark Sweep) : deprecated 

<br>


---- 논리적인 단위로 구분 region영역,ZPage영역 ----


#### G1 GC (Garbage First) (Java 9+ default) 

Region으로 체스같이 분할 상황에 따라 Eden, Survivor, Old 등 역할 동적 부여

가비지가 많은 리전을 우선적으로 정리

설정된-XX:MaxGCPauseMillis 내에서 작업 수행.

<br>

#### ZGC (Z Garbage Collector) (Java 15에 release)
ZPage 영역, G1의 region은 크기가 고정인데 비해, ZPage는 2mb 배수로 동적으로 운영
(객체의 크기에 따라 영역이 할당)

![image](https://github.com/user-attachments/assets/d706585d-065d-446d-8089-c74dc047fcdc)


<br>

#### Shenandoah GC (Java 12 도입)

<br>
<br>

Reference  : 
[gc동작원리](https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EA%B0%80%EB%B9%84%EC%A7%80-%EC%BB%AC%EB%A0%89%EC%85%98GC-%EB%8F%99%EC%9E%91-%EC%9B%90%EB%A6%AC-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%F0%9F%92%AF-%EC%B4%9D%EC%A0%95%EB%A6%AC)
<br>

[Garbage Collection 동작 원리 및 종류](https://m.blog.naver.com/web-developer/223345931298)

<br>

[네이버기술블로그 ZGC](https://m.blog.naver.com/web-developer/223345931298)
