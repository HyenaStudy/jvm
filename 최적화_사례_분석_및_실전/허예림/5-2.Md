## 5-2. 사례 분석

애플리케이션 배포 수준에서 발생할 수 있는 문제

- 설계 / 개발 단계에서 해결 할 수 있는 문제
- 하드웨어를 업그레드하거나 JDK를 최신 버전으로 적용하면 해결되는 문제
- **기존 하드웨어와 소프트웨어를 유지한 채 배포와 설정 전략을 조율하여 문제를 풀거나 완화하는 방법**

### 사례 1 ) 대용량 메모리 기기 대상 배포 전략

- 자바 힙 고정 크기를 12GB로 고정 (-Xmx,-Xms) → 장기간 미응답 및 응답 지연 발생
- 응답 지연 원인 : 가비지 컬렉션
    - 패러렐 컬렉터는 일시정지 시간보다 처리량에 중점을 둔 컬렉터 → 12GB에 달하는 힙을 처리하기 까지 14초까지 걸렸다.

**대용량 메모리를 갖춘 하드웨어에 단일 자바 애플리케이션을 배포할 때 고려할 수 있는 가비지 컬렉션**

1. 세년도어
    - 큰 힙에서 지연 시간을 줄이고자 할 때 적합
    - G1GC와 유사하나 더 낮은 지연시간을 목표
2. ZGC (초저지연, 대규모 힙에서도 안정적)
    - 매우 큰 메모리를 사용하는 애플리케이션에서 적합 (테라바이트 수준)
    - GC의 지연시간이 매우 낮게 유지되어야 하는 경우
3. 패러럴
    - GC 지연 시간보다는 전체 처리량이 중요한 경우
    - 배치 작업이나 대규모 데이터 처리 애플리케이션에서 적합
4. G1GC
    - 수백 GB이상의 메모리 사용, 낮은 GC 지연 시간과 높은 처리량
    - 중간 크기의 객체가 많이 생성되고 오래 유지되는 경우
    - 지연시간을 설정해 특정 지연 시간 내 GC가 완료되도록 조정 가능

### 사례 2 ) 클러스터 간 동기화로 인한 메모리 오버플로

- 듀얼 프로세서, 8GB 메모리를 가진 서버 2대에서 WebLogic 서버로 클러스터를 구성.
- JBossCache를 사용하여 글로벌 캐시를 구축.

→ 종종 메모리 오버플로우 발생, 힙 덤프 분석 결과 `org.jgroups.protocols.pbcast.NAKACK` 객체가 문제의 주요 원인으로 밝혀짐.

- 원인 : 글로벌 캐시에서 과부화 발생
    - 글로벌 캐시 동작 방식
        - JBossCache는 클러스터 노드 간의 데이터 동기화를 위해 **JGroups**를 사용합니다.
        - 글로벌 캐시에서는 데이터가 한 노드에서 변경되면, 변경된 데이터가 **모든 노드에 동기화**되어야 합니다.
        - 이 과정에서 데이터 동기화 작업이 빈번해지면 네트워크 트래픽과 메모리 사용량이 급증할 수 있습니다.
    - 동시 요청 처리의 병목 현상
        - 글로벌 캐시는 다수의 클라이언트 요청을 처리해야 하는데, 특정 시점에서 **필터 요청**이 대량으로 발생하면 각 노드가 변경된 데이터를 서로 주고받으며 병목 현상이 발생.
        - 결과적으로, 메모리에 대량의 **전송 대기 데이터**가 쌓여 메모리 오버플로우로 이어짐.
    - NAKACK 객체로 인한 문제
        - JGroups에서 노드 간 메시지 재전송과 신뢰성 보장을 담당하는 객체
        - 네트워크 통신 지연이나 데이터 손실이 발생하면, 이 객체가 재전송 메시지를 관리하기 위해 메모리를 더 많이 사용
        - 네트워크 과부하로 인해 재전송 메시지가 폭증하면 메모리 사용량이 급격히 증가하여 오버플로우가 발생할 가능성이 높아짐
1. **문제의 원인:**
    - JGroups를 사용한 클러스터 노드 간의 통신 과정에서 네트워크 과부하.
    - 필터 요청이 동시에 다수 발생하면서 클러스터 노드 사이의 데이터 동기화가 빈번해짐.
    - 데이터 전송량 증가로 인해 재전송 데이터가 메모리에 쌓여 오버플로우 발생.
2. **추가 요인:**
    - JBossCache의 동기화 방식이 네트워크 통신과 메모리 사용량을 증가시킴.
    - 지역 캐시에서는 문제가 적지만, 클러스터 전체 데이터를 공유해야 하는 글로벌 캐시에서는 과부하가 발생.
3. **결론:**
    - **동기화 빈도 줄이기** : 글로벌 캐시를 사용할 때는 데이터 동기화 빈도를 줄이고, 네트워크 및 메모리 자원 사용을 최적화해야 함. → 비동기 동기화 방식으로 전환
    - 글로벌 캐시의 범위 축소 → 모든 데이터를 글로벌 캐시에 저장하지 않도록 설정
    - JGroups에서 메시지 재전송 횟수를 제한하는 등 프로토콜 최적화
    - 메모리 사용 모니터링 -XX:+HeapDumpOnOutOfMemoryError

결론적으로, 클러스터 시스템의 메모리와 네트워크 효율성을 위해 캐시 관리와 동기화 설정이 중요하며, 분산 환경에서는 자원 최적화가 필수입니다.

### 사례 3) 힙 메모리 부족으로 인한 오버플로 오류

### **시스템 환경**

- **서버 구성:** CometD 1.1.1 푸시 프레임워크와 Jetty 7.1.4 사용.
- **하드웨어:** 인텔 i5 CPU, 4GB 메모리, 32비트 윈도우.
- **문제:** 메모리 오버플로우로 인해 시스템 전체가 중단되는 현상 발생.

---

### **문제의 원인**

1. **메모리 제한:**
    - 32비트 시스템의 메모리 한계(2GB)로 인해 다이렉트 메모리 부족 발생.
    - 힙 메모리 외에도 다이렉트 메모리, 스택 영역 등 다양한 메모리 자원을 사용.
2. **다이렉트 메모리 문제:**
    - 다이렉트 메모리는 **Java NIO**에서 네이티브 I/O 작업을 빠르게 처리하기 위해 JVM 힙 외부에서 사용하는 메모리
    - `XX:MaxDirectMemorySize`의 기본 크기를 초과하면서 예외 발생.
        - 설정하지 않으면 힙 크기와 동일한 크기로 간주
    - NIO 연산에서 다이렉트 메모리를 많이 소모. → 가비지 컬렉터가 관리하지 않기 떄문

---

### **해결 방법**

1. **다이렉트 메모리 조정:**
    - `XX:MaxDirectMemorySize` 옵션으로 크기 조정.
2. **스택 메모리 조정:**
    - `Xss` 옵션으로 스레드 스택 크기 조정.
3. **가비지 컬렉터 설정:**
    - 적절한 가비지 컬렉터를 선택하거나 수동 GC 호출(`System.gc()`) 고려.
4. **운영 체제와 메모리 용량 업그레이드:**
    - 64비트 운영 체제와 더 큰 메모리를 활용하여 한계를 극복.

---

### **결론**

메모리 자원이 제한된 환경에서는 다이렉트 메모리, 힙, 스택 등 다양한 메모리 영역의 적절한 관리가 필수적입니다. 시스템 아키텍처와 메모리 활용 방식을 개선해야 안정적인 서비스를 제공할 수 있습니다.

### 사례 4 ) 시스템을 느려지게하는 외부 명령어

### **시스템 환경**

- **구성:** GlassFish 미들웨어와 4개의 프로세서가 장착된 Solaris 10 시스템.
- **문제:** 스트레스 테스트 중 시스템의 응답 속도가 크게 느려지고 프로세서 자원이 비정상적으로 소모됨.

---

### **문제의 원인**

1. **프로세스 자원 과다 사용:**
    - `mpstat` 도구로 분석 결과, 대부분의 프로세서 자원을 소모하는 주체가 비정상적인 동작을 함.
    - 사용자가 실행한 요청이 자바 애플리케이션에서 외부 셀 스크립트를 호출하도록 구현되어 있었음. → 요청이 많아질수록 외부 스크립트 호출이 빈번해져, 프로세서 사용량이 과도하게 증가.
2. **외부 명령 호출 과정:**
    - 자바의 `Runtime.getRuntime().exec()` 메서드로 셀 스크립트를 실행.
    - 외부 명령 호출은 새로운 프로세스를 생성하기 때문에, 이 과정에서 CPU와 메모리를 추가로 소비., 프로세스를 생성하는 과정에서 상당한 오버헤드 발생

---

### **해결 방안**

1. **셀 스크립트 호출 제거:**
    - 셀 스크립트를 실행하는 코드를 삭제.
    - 필요한 정보를 자바 API로 직접 가져오도록 변경.

---

### **결론**

외부 명령을 반복적으로 호출하는 것은 프로세서와 메모리 자원을 과도하게 사용하여 시스템 성능 저하를 초래할 수 있습니다. 이를 방지하려면 셀 스크립트를 대체할 적절한 자바 API를 활용하여 자원 소모를 줄이고 시스템 안정성을 확보해야 합니다.

###