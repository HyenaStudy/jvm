# 10.1

## 용어 정리

컴파일러의 프론트엔드와 백엔드(+ 덤으로 미들엔드)는 웹 개발 용어와 다르다. 컴파일 수행 단계에 따라 프론트엔드, 미들엔드, 백엔드로 나뉘어진다.

<img width="664" alt="스크린샷 2025-01-08 오전 1 02 52" src="https://github.com/user-attachments/assets/f13daf91-c22d-486e-aa08-82fa40515787" />

### (1) 프론트엔드 (Frontend)
- **입력 처리**: 자바 소스 코드를 읽고 어휘 분석(Lexical Analysis), 구문 분석(Syntax Analysis), 의미 분석(Semantic Analysis)을 통해 문법과 의미가 올바른지 검증
- **타입 검사**: 정적 타입 언어 특성에 맞춰 변수나 메서드 호출에 대한 타입 검사를 수행하여 타입 오류 탐색
- **중간 표현(IR) 생성**: 소스 코드가 중간 표현(Intermediate Representation, IR)으로 변환\
\
*IR은 자바 바이트코드에 가까운 낮은 수준의 표현으로, 이후 최적화 및 코드 생성 단계에서 사용*

### (2) 미들엔드 (Middle End)
- **최적화**: 중간 표현(IR)을 최적화하여 성능 개선. CPU 아키텍처와 관계없이 공통적으로 적용할 수 있는 기법인 죽은 코드 제거(Dead-code elimination), 상수 전파(Constant propagation), 루프 최적화 등
- **CPU 독립성**: 미들엔드에서 수행되는 최적화는 다양한 하드웨어 및 운영 체제에서 공통적으로 적용될 수 있도록 설계

### (3) 백엔드 (Backend)
- **CPU 아키텍처 의존 최적화**: 미들엔드에서 최적화된 IR을 받아, 타겟 CPU 아키텍처에 맞는 추가적인 최적화 및 변환 작업 수행(레지스터 할당(Register Allocation), 명령어 스케줄링(Instruction Scheduling) 등)
- **어셈블리 코드 생성**: 최종적으로 CPU에서 실행될 수 있는 **머신 코드** 또는 **어셈블리 코드** 생성. 이 코드는 특정 프로세서와 운영 체제에 최적화되어 실행.

10장에서는 컴파일 프론트엔드 단계에 대해 알아볼 예정

---

# 10.2

## 컴파일러의 종류

참고로 자바 컴파일러 자체는 일종의 컴파일러 종류에 불과하다. 즉, 자바 컴파일러라는 특정한 것이 존재하는 게 아니라 그저 자바 소스 코드를 바이트코드로 변환하는 프로그램에 불과할 뿐이며 이것들을 실현하는 구현체가 다양하게 존재한다. 흡사 JPA와 Hibernate의 관계와 흡사하다고 볼 수 있다.

#### (1) Javac (Java Compiler)
- 공식 OpenJDK 컴파일러
- 자바 개발 키트(JDK)에 기본 포함
- 자바로 작성된 자바 컴파일러
- 대부분의 자바 프로젝트에서 표준으로 사용
#### (2) Eclipse JDT (Java Development Tools)
- Eclipse IDE에 내장된 자바 컴파일러
- org.eclipse.jdt.core.compiler 패키지에서 제공
- 즉각적인 구문 오류 감지 및 증분 컴파일(Incremental Compilation) 기능 제공
- 자바로 작성되었으며, Eclipse 플러그인으로 통합
#### (3) ECJ (Eclipse Compiler for Java)
- Eclipse IDE의 독립형 컴파일러
- JDT와 동일한 엔진을 사용하지만, Eclipse 없이도 사용 가능
- 명령어 기반(ecj)로 Javac의 대안으로 사용
#### (4) GraalVM Native Image Compiler
- 고성능 JIT(Just-In-Time) 및 AOT(Ahead-Of-Time) 컴파일러
- 자바 코드의 네이티브 바이너리 변환 지원
- 마이크로서비스와 경량 애플리케이션에 자주 사용
#### (5) Jikes (IBM)
- IBM에서 개발한 자바 컴파일러
- C++ 기반으로 작성
- 빠른 컴파일 속도 제공했으나, 현재는 사용 빈도가 낮고 개발 중단

## 프론트엔드 컴파일링

컴파일러 프론트엔드 단계에서는 **문법 검증**, 그리고 이를 통한 **추상 구문 트리(AST)** 를 생성한다. 문법 검증은 말 그대로 자바 코드의 어휘를 분석하고 소스 코드의 문법 구조를 파악하며 정적 타입 검증 및 변수와 메소드의 범위 검사가 이뤄진다. 이 과정이 끝나면 바이트코드 생성의 바로 직전 단계인 AST를 생성하게 되는데 AST의 T가 트리 자료구조를 뜻한다. 자바 문법의 계층 구조를 나타내며 각 노드는 프로그램의 구성 요소를 담고있고 이를 기반으로 IR이 생성되어 컴파일러 백엔드에 전달할 준비를 마무리한다.

프론트엔드 컴파일러 단계의 주요 처리 과정은 다음과 같다.

1. 구문 분석 및 심볼 테이블 채우기
2. 어노테이션 처리
3. 의미 분석 및 바이트코드 생성

이 단계들을 확인하고 분석하기 전에, 내가 사용하는 IDE는 인텔리제이고 자바 버전은 OpenJDK LTS 21을 사용하고 있기 때문에 Javac를 활용해서 컴파일링 과정을 최대한 디버깅해볼 예정...이었으나 워낙에 관여되는 프론트엔드 코드들이 많아서 일단은 개념적으로 컴파일링의 프론트엔드 과정을 톺아보고 보편적인 컴파일과 제네릭 타입의 컴파일을 비교 확인해볼 예정.

### 컴파일 모듈 개념 정리

자바 프로젝트의 외부 라이브러리 모듈들을 확인하면 `java.compiler`와 `jdk.compiler` 두 개가 확인된다.

<img width="80%" alt="스크린샷 2025-01-15 오후 3 54 19" src="https://github.com/user-attachments/assets/c1f1964f-7d4c-4056-b561-fdf4c335759a" />

아까 위에서 수많은 자바 컴파일러의 종류들을 간략히 짚었는데 이들의 추상체가 바로 `java.compiler`다.\
정확히 표현하자면 **`java.comiler`의 구현체 중 하나가 `jdk.compiler`**가 된다. 마치 JPA의 구현체 중 하나인 Hibernate와 같은 관계인 셈이다.

<img width="80%" alt="스크린샷 2025-01-15 오후 4 12 16" src="https://github.com/user-attachments/assets/97969ca9-4124-4c72-b4a3-a54b5f053169" />

이 `java.compiler`라는 추상체들 중 가장 핵심 인터페이스 추상체가 `JavaCompiler` 인터페이스인데 이것을 활용하여 **런타임 때에 동작하는 동적 컴파일러도 구현**이 가능하다. 아래 코드는 동적으로 경로 `"/src/Subject.java"`의 자바 파일을 동적으로 생성하고 컴파일하는 예제 코드다. 이것을 수행하면 `Subject.class`라는 컴파일 결과를 확인할 수 있다.

```java
import java.io.File;
import java.util.List;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;

public class CompilerTest {
    public static void main(String[] args) {
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);

        // 컴파일할 소스 파일 지정
        File sourceFile = new File("src/Example.java");
        Iterable<? extends JavaFileObject> files = fileManager.getJavaFileObjects(sourceFile);

        // 컴파일 옵션 추가
        List<String> options = List.of("-verbose", "-Xlint:deprecation");

        // 컴파일 작업을 위한 CompilationTask 객체 생성
        JavaCompiler.CompilationTask task = compiler.getTask(
                null, fileManager, null, options, null, files
        );

        // 컴파일 실행
        boolean success = task.call();

        // 컴파일 결과 확인
        if (success) {
            System.out.println("컴파일 성공");
        } else {
            System.out.println("컴파일 실패");
        }
    }
}
```

추후에 컴파일링의 백엔드 과정에서 JIT의 최적화 전략 등을 톺아볼 수 있어서 지금 내용은 여기서 생략한다.

## 프론트엔드 컴파일링 단계 세부 분석

여담으로 교재에서 언급하는 웬만한 메소드들은 자바의 모듈 속에 존재하는 클래스나 인터페이스의 메소드가 아닌, **컴파일러의 내부 메소드**이기 떄문에 직접 눈으로 볼 수는 없다(...~~이거 때문에 모듈 뜯어본다고 개고생을 했는데...~~) 순수히 컴파일러의 라이프사이클을 따라가는 정말 기능에만 충실한 메소드들이기 때문에 개략적으로만 어떤 것들이 있는지 파악하기만 하자...

### 1) 구문 분석 및 심볼 테이블 채우기

#### (1) 구문 분석

자바 소스 코드에서 어휘 분석을 담당하는 코드는 `com.sun.tools.javac.parser.Scanner` 클래스다. 좀 더 정확히 따져보면 아래 순서로 이뤄진다.

1. `JavaCompiler` 클래스에서 입력 스트림을 받아들인다.
2. `Scanner` 클래스로 소스 코드의 문자 스트림을 읽고 **토큰**으로 분리한다. `token()` 메소드를 통해 다음 토큰을 반환시킨다.
3. 1번 과정을 통해 얻은 토큰을 바탕으로 `JavacParser` 클래스의 `nextToken()` 메소드로 어휘 분석을 수행한다. 이 과정은 AST 생성을 위한 단계다.

중요한 게, 이 토큰화 과정이라는 게 문법 해석은 아니다. 순수히 어휘적인 의미로 띄어쓰기 전부 소거하듯이 분리한다. 예를 들어서 예를 들어, `int a = 5;`라는 코드에서 `int`, `a`, `=`, `5`, `;` 등 각 요소는 별개의 토큰으로 분리할 뿐이지, `int`가 어떤 타입인지 등의 해석이은 이 단계 이후에서 처리된다. 토큰화 과정이란 키워드는 말 그대로 토큰으로 만드는 것에만 집중한다.

어휘 분석이 끝나고 나면 문법 해석이 이뤄지는데, 이것들은 `JavacParser` 클래스의 `parseXXX()`, 즉 parse 접두어를 가지는 메소드들을 통해 문법 분석이 이뤄진다. 이 내부에서 `term()`이라는 오버로딩 메소드를 호출하는데 또 이 메소드들 내부에는 `JCExpression` 타입들이 확인되고 얘네들이 AST의 표현식 노드들이 된다. 내용이 좀 어렵던데 나는 일단 `JCTree`가 AST의 프레임을 제공하고 그 내부 노드들은 `JCExpression` 구현체(`JCIdent`, `JCLiteral`, `JCMethodInvocation`, `JCBinary` 등)들이 맡는 것으로 이해했다.

<img width="85%" alt="스크린샷 2025-01-15 오후 5 07 07" src="https://github.com/user-attachments/assets/09064bb3-3db0-4376-8687-f65616c277be" />

<img width="85%" alt="스크린샷 2025-01-15 오후 5 05 45" src="https://github.com/user-attachments/assets/2044070a-8b77-49d5-bd43-c7429dfe9a4c" />

#### (2) 심벑 테이블

심벌 테이블을 채운다는 뜻은 컴파일러가 소스 코드를 분석할 때, 프로그램 내에서 사용되는 **식별자(변수, 함수, 클래스 등)** 에 대한 정보를 구조화된 형태로 저장하는 과정이며 이를 통해서 소스 코드의 타입 검사와 스코프 관리, 중복 선언 검사 등을 가능하게 한다는 뜻이다. AST의 노드를 채우는 것과는 다른데 AST 노드는 구문적 분석을 통해 채워넣은 내용들의 실질적인 의미인 타입, 명칭 등의 식별자 관련 내용들을 심벌 테이블에 채워서 상호보완적으로 동작한다.

<img width="85%" alt="스크린샷 2025-01-15 오후 5 22 27" src="https://github.com/user-attachments/assets/4477caba-825f-4c4a-bf8d-de9bf89dfb84" />

위의 `Enter` 클래스는 `JCTree` 관련 작업 외에도 심벌 테이블과 관련된 작업들을 맡는데 대표적인 필드들은 아래와 같다.

- `Symtab syms`
    - 심벌 테이블 자체를 관리하는 필드
    - 코드에서 정의된 식별자(예: 클래스, 변수, 메소드 등)에 대한 심볼을 저장하고, 식별자의 이름, 타입, 위치 등과 같은 실질적인 정보를 관리
- `Names names`
    - 식별자 이름을 관리하는 클래스 코드에서 사용되는 이름들을 추적하고, 이름에 대한 관련 정보를 제공하는 데 사용
- `Types types`
    - 식별자(변수, 메소드, 클래스 등)에 대한 타입 정보를 관리하고, 심볼 테이블에 각 식별자의 타입 정보를 올바르게 등록
- `TypeEnter typeEnter`
    - 타입 시스템에 맞춰 식별자들의 타입을 등록하고, 이 타입 정보가 정확하게 심볼 테이블에 들어가도록 관리하는 역할
- `Modules modules`
    - 모듈 시스템과 관련된 정보(의존성 관계 등)를 관리







