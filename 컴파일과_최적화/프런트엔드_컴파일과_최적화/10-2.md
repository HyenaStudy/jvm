<img width="1394" alt="스크린샷 2025-01-08 오후 7 36 15" src="https://github.com/user-attachments/assets/40997031-f554-4991-854b-8af5e72c2033" /># 10.1

## 용어 정리

컴파일러의 프론트엔드와 백엔드(+ 덤으로 미들엔드)는 웹 개발 용어와 다르다. 컴파일 수행 단계에 따라 프론트엔드, 미들엔드, 백엔드로 나뉘어진다.

<img width="664" alt="스크린샷 2025-01-08 오전 1 02 52" src="https://github.com/user-attachments/assets/f13daf91-c22d-486e-aa08-82fa40515787" />

### (1) 프론트엔드 (Frontend)
- **입력 처리**: 자바 소스 코드를 읽고 어휘 분석(Lexical Analysis), 구문 분석(Syntax Analysis), 의미 분석(Semantic Analysis)을 통해 문법과 의미가 올바른지 검증
- **타입 검사**: 정적 타입 언어 특성에 맞춰 변수나 메서드 호출에 대한 타입 검사를 수행하여 타입 오류 탐색
- **중간 표현(IR) 생성**: 소스 코드가 중간 표현(Intermediate Representation, IR)으로 변환\
\
*IR은 자바 바이트코드에 가까운 낮은 수준의 표현으로, 이후 최적화 및 코드 생성 단계에서 사용*

### (2) 미들엔드 (Middle End)
- **최적화**: 중간 표현(IR)을 최적화하여 성능 개선. CPU 아키텍처와 관계없이 공통적으로 적용할 수 있는 기법인 죽은 코드 제거(Dead-code elimination), 상수 전파(Constant propagation), 루프 최적화 등
- **CPU 독립성**: 미들엔드에서 수행되는 최적화는 다양한 하드웨어 및 운영 체제에서 공통적으로 적용될 수 있도록 설계

### (3) 백엔드 (Backend)
- **CPU 아키텍처 의존 최적화**: 미들엔드에서 최적화된 IR을 받아, 타겟 CPU 아키텍처에 맞는 추가적인 최적화 및 변환 작업 수행(레지스터 할당(Register Allocation), 명령어 스케줄링(Instruction Scheduling) 등)
- **어셈블리 코드 생성**: 최종적으로 CPU에서 실행될 수 있는 **머신 코드** 또는 **어셈블리 코드** 생성. 이 코드는 특정 프로세서와 운영 체제에 최적화되어 실행.

10장에서는 컴파일 프론트엔드 단계에 대해 알아볼 예정

---

# 10.2

## 컴파일러의 종류

참고로 자바 컴파일러 자체는 일종의 컴파일러 종류에 불과하다. 즉, 자바 컴파일러라는 특정한 것이 존재하는 게 아니라 그저 자바 소스 코드를 바이트코드로 변환하는 프로그램에 불과할 뿐이며 이것들을 실현하는 구현체가 다양하게 존재한다. 흡사 JPA와 Hibernate의 관계와 흡사하다고 볼 수 있다.

#### (1) Javac (Java Compiler)
- 공식 OpenJDK 컴파일러
- 자바 개발 키트(JDK)에 기본 포함
- 자바로 작성된 자바 컴파일러
- 대부분의 자바 프로젝트에서 표준으로 사용
#### (2) Eclipse JDT (Java Development Tools)
- Eclipse IDE에 내장된 자바 컴파일러
- org.eclipse.jdt.core.compiler 패키지에서 제공
- 즉각적인 구문 오류 감지 및 증분 컴파일(Incremental Compilation) 기능 제공
- 자바로 작성되었으며, Eclipse 플러그인으로 통합
#### (3) ECJ (Eclipse Compiler for Java)
- Eclipse IDE의 독립형 컴파일러
- JDT와 동일한 엔진을 사용하지만, Eclipse 없이도 사용 가능
- 명령어 기반(ecj)로 Javac의 대안으로 사용
#### (4) GraalVM Native Image Compiler
- 고성능 JIT(Just-In-Time) 및 AOT(Ahead-Of-Time) 컴파일러
- 자바 코드의 네이티브 바이너리 변환 지원
- 마이크로서비스와 경량 애플리케이션에 자주 사용
#### (5) Jikes (IBM)
- IBM에서 개발한 자바 컴파일러
- C++ 기반으로 작성
- 빠른 컴파일 속도 제공했으나, 현재는 사용 빈도가 낮고 개발 중단

## 프론트엔드 컴파일링

컴파일러 프론트엔드 단계에서는 **문법 검증**, 그리고 이를 통한 **추상 구문 트리(AST)** 를 생성한다. 문법 검증은 말 그대로 자바 코드의 어휘를 분석하고 소스 코드의 문법 구조를 파악하며 정적 타입 검증 및 변수와 메소드의 범위 검사가 이뤄진다. 이 과정이 끝나면 바이트코드 생성의 바로 직전 단계인 AST를 생성하게 되는데 AST의 T가 트리 자료구조를 뜻한다. 자바 문법의 계층 구조를 나타내며 각 노드는 프로그램의 구성 요소를 담고있고 이를 기반으로 IR이 생성되어 컴파일러 백엔드에 전달할 준비를 마무리한다.

프론트엔드 컴파일러 단계의 주요 처리 과정은 다음과 같다.

1. 구문 분석 및 심볼 테이블 채우기
2. 어노테이션 처리
3. 의미 분석 및 바이트코드 생성

이 단계들을 확인하고 분석하기 전에, 내가 사용하는 IDE는 인텔리제이고 자바 버전은 OpenJDK LTS 21을 사용하고 있기 때문에 Javac를 활용해서 컴파일링 과정을 최대한 디버깅해볼 예정...

### 예제 코드 및 컴파일링

일반적으로 자바 코드는 개발자가 작성 후, 컴파일러를 통해 빌드 타임에 컴파일된 후에야 실행(런타임 과정)이 된다. 다만 그렇게 되면 IDE에서 디버깅을 할 수 없기 때문에 런타임 시점에 동적으로 컴파일을 수행하면서 실제 컴파일에 관여하는 `jdk.compiler` 라이브러리 패키지에 존재하는 코드들을 확인해본다.

예제 코드는 아래와 같다.

```java
public class Example {
    private String name;
    private static int number = 1;

    public Example() {
        this.name = "김동준";
    }

    public void getName() {
        System.out.println("내 이름은 " + this.name);
    }

    @Deprecated
    public void setName(String name) {
        this.name = name;
        System.out.println("바퀸 이름은 " + this.name);
    }

    public static void setNumber(int newNumber) {
        number = newNumber;
    }

    public static void main(String[] args) {
        Example example = new Example();
        example.getName();
        Example.setNumber(2);
        example.setName("바뀐 이름");
    }
}
```

해당 소스 코드의 위치는 `/src/Example.java`이며, 이 위치를 기반으로 런타임 컴파일을 수행하는 코드를 세팅한다.

```java
import java.io.File;
import java.util.List;
import javax.tools.JavaCompiler;
import javax.tools.JavaFileObject;
import javax.tools.StandardJavaFileManager;
import javax.tools.ToolProvider;
import javax.tools.Diagnostic;
import javax.tools.DiagnosticCollector;

public class CompilerTest {
    public static void main(String[] args) {
        // JavaCompiler 객체(JRE에서는 사용 불가)
        JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();

        // 파일 관리자(파일을 처리하는 데 사용됨)를 설정
        StandardJavaFileManager fileManager = compiler.getStandardFileManager(null, null, null);

        // 컴파일할 소스 파일 지정 (예: src/Example.java)
        File sourceFile = new File("src/Example.java");
        Iterable<? extends JavaFileObject> files = fileManager.getJavaFileObjects(sourceFile);

        // 컴파일 옵션 추가 (예: -verbose와 -Xlint:deprecation로 경고 메시지 확인)
        List<String> options = List.of("-verbose", "-Xlint:deprecation");

        // 컴파일 작업을 위한 CompilationTask 객체 생성
        JavaCompiler.CompilationTask task = compiler.getTask(
                null, fileManager, null, options, null, files
        );

        // 컴파일 실행
        boolean success = task.call();

        // 컴파일 결과 확인
        if (success) {
            System.out.println("컴파일 성공");
        } else {
            System.out.println("컴파일 실패");
        }
    }
}
```

런타임 컴파일이라는 것은 결국 코드가 실행되는 런타임 시점에 동적으로 컴파일이 이뤄지는 것이다. 디버깅 브레이크 포인트를 `jdk.compiler` 라이브러리 코드에도 같이 찍으면서 역할들을 전부 체킹하면서 확인한다.

#### (1) 구문 분석 및 심볼 테이블 채우기

자바 소스 코드에서 어휘 분석을 담당하는 코드는 `com.sun.tools.javac.parser.Scanner` 클래스다. 좀 더 정확히 따져보면 아래 순서로 이뤄진다.

1. `JavaCompiler` 클래스에서 입력 스트림을 받아들인다.
1. `Scanner` 클래스로 소스 코드의 문자 스트림을 읽고 **토큰**으로 분리한다. `token()` 메소드를 통해 다음 토큰을 반환시킨다.
2. 1번 과정을 통해 얻은 토큰을 바탕으로 `JavacParser` 클래스의 `nextToken()` 메소드로 구문 분석을 수행한다. 이 과정은 AST 생성을 위한 단계다.

<img width="80%" alt="스크린샷 2025-01-08 오후 7 36 15" src="https://github.com/user-attachments/assets/9791fea4-dc1a-40f6-bd73-fda12760e2af" />







