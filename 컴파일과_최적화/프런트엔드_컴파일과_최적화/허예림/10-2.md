### 자바의 컴파일 과정

**프런트엔드 컴파일러 (javac)**:자바 소스 코드(.java)를 바이트코드(.class)로 변환

1. **클래스 로딩 (Class Loader)**:JVM이 필요한 .class 파일을 메모리에 로드
2. **바이트코드 검증 (Bytecode Verification)**:JVM이 바이트코드의 유효성을 검사
3. **인터프리터 또는 JIT 컴파일러 실행**:
    - **인터프리터**: 바이트코드를 한 줄씩 해석하여 실행
    - **JIT 컴파일러**: 자주 실행되는 코드를 네이티브 코드로 변환하여 실행 속도 향상
4. **(선택적) AOT 컴파일러 실행**:실행 전에 미리 바이트코드를 네이티브 코드로 변환하여 실행 속도를 최적화

### 프런트엔드 컴파일러

javac는 자바 소스 코드(.java)를 바이트코드(.class 파일)로 변환하는 **프런트엔드 컴파일러**입니다.
javac의 전체적인 동작 과정은 다음과 같습니다:

1. **소스 코드 로딩 (JavaFileManager)**
2. **파싱 및 AST 생성 (Parser)**
3. **구문 및 의미 분석 (Enter, MemberEnter, Attr)**
4. **중간 표현(IR) 변환 및 최적화 (Flow, TransTypes)**
5. **코드 생성 및 바이트코드 출력 (Gen)**

각 과정은 `com.sun.tools.javac.main.JavaCompiler` 클래스 내에서 수행됩니다.

### 동작 과정

1. compile() 메서드 (컴파일의 시작점)
    - compile() 메서드는 .java 소스 파일 리스트를 받아 컴파일을 수행하는 핵심 엔트리 포인트입니다.
    - 아래로 컴파일 내부의 동작 과정입니다.
2. initProcessAnnotations(processors);
3. parseFiles(sourceFileObjects) : (파싱 및 AST 생성)
    - **파싱 (parseFiles())**→ .java 파일을 읽고 **AST(Abstract Syntax Tree) 생성**
    - 키워드, 변수 이름, 리터럴, 연산자와 같은 토큰 기준으로 생성
    - int a = b + 2 → (int, a, =, b, +, 2)
    - 추상 구문 트리 생성 이후 소스 코드의 문자 스트림은 더이상 사용 되지 않습니다.
4. enterTrees() : (구문 및 의미 분석)
    - **구문 및 의미 분석 (enterTrees())**→ 클래스, 메서드, 변수 정의를 확인하고 **타입 체크 수행**
5. processAnnotations
6. analyzeAndGenerateCode() : (코드 분석 및 바이트 코드 생성)
    - **코드 분석 및 바이트코드 생성 (analyzeAndGenerateCode())**→ AST를 바이트코드로 변환 후 .class 파일 생성
7. cleanup()

### 실행 예제

```java
public class Test {
    public static void main(String[] args) {
        System.out.println("Hello, World!");
    }
}
```

### 실제 코드

https://github.com/openjdk/jdk/blob/master/src/jdk.compiler/share/classes/com/sun/tools/javac/main/JavaCompiler.java

```jsx
    public void compile(Collection<JavaFileObject> sourceFileObjects,
                        Collection<String> classnames,
                        Iterable<? extends Processor> processors,
                        Collection<String> addModules)
    {
        if (!taskListener.isEmpty()) {
            taskListener.started(new TaskEvent(TaskEvent.Kind.COMPILATION));
        }

        // as a JavaCompiler can only be used once, throw an exception if
        // it has been used before.
        if (hasBeenUsed)
            checkReusable();
        hasBeenUsed = true;

        // forcibly set the equivalent of -Xlint:-options, so that no further
        // warnings about command line options are generated from this point on
        options.put(XLINT_CUSTOM.primaryName + "-" + LintCategory.OPTIONS.option, "true");
        options.remove(XLINT_CUSTOM.primaryName + LintCategory.OPTIONS.option);

        start_msec = now();

        try {
            initProcessAnnotations(processors, sourceFileObjects, classnames);

            for (String className : classnames) {
                int sep = className.indexOf('/');
                if (sep != -1) {
                    modules.addExtraAddModules(className.substring(0, sep));
                }
            }

            for (String moduleName : addModules) {
                modules.addExtraAddModules(moduleName);
            }

            // These method calls must be chained to avoid memory leaks
            processAnnotations(
                enterTrees(
                        stopIfError(CompileState.ENTER,
                                initModules(stopIfError(CompileState.ENTER, parseFiles(sourceFileObjects))))
                ),
                classnames
            );

            // If it's safe to do so, skip attr / flow / gen for implicit classes
            if (taskListener.isEmpty() &&
                    implicitSourcePolicy == ImplicitSourcePolicy.NONE) {
                todo.retainFiles(inputFiles);
            }

            if (!CompileState.ATTR.isAfter(shouldStopPolicyIfNoError)) {
                switch (compilePolicy) {
                case SIMPLE:
                    generate(desugar(warn(flow(attribute(todo)))));
                    break;

                case BY_FILE: {
                        Queue<Queue<Env<AttrContext>>> q = todo.groupByFile();
                        while (!q.isEmpty() && !shouldStop(CompileState.ATTR)) {
                            generate(desugar(warn(flow(attribute(q.remove())))));
                        }
                    }
                    break;

                case BY_TODO:
                    while (!todo.isEmpty())
                        generate(desugar(warn(flow(attribute(todo.remove())))));
                    break;

                default:
                    Assert.error("unknown compile policy");
                }
            }
        } catch (Abort ex) {
            if (devVerbose)
                ex.printStackTrace(System.err);

            // In case an Abort was thrown before processAnnotations could be called,
            // we could have deferred diagnostics that haven't been reported.
            reportDeferredDiagnosticAndClearHandler();
        } finally {
            if (verbose) {
                elapsed_msec = elapsed(start_msec);
                log.printVerbose("total", Long.toString(elapsed_msec));
            }

            reportDeferredDiagnostics();

            if (!log.hasDiagnosticListener()) {
                printCount("error", errorCount());
                printCount("warn", warningCount());
                printSuppressedCount(errorCount(), log.nsuppressederrors, "count.error.recompile");
                printSuppressedCount(warningCount(), log.nsuppressedwarns, "count.warn.recompile");
            }
            if (!taskListener.isEmpty()) {
                taskListener.finished(new TaskEvent(TaskEvent.Kind.COMPILATION));
            }
            close();
            if (procEnvImpl != null)
                procEnvImpl.close();
        }
    }

```