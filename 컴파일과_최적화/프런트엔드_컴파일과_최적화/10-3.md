# 10-3

## 타입 소거

### (1) 정의

자바 5에서 도입된 제네릭은 자바의 객체지향성 실현을 위한 중요한 키워드 중 하나다. 학문적인 정의로는 **클래스 내부에서 사용할 데이터 타입을 외부에서 지정하는 기법**이라 할 수 있고 이것을 컴파일과 연관지으면 **보편적인 소스 코드는 컴파일 시점에 타입이 전부 정해지고 제네릭 역시 마찬가지지만 다른 소스코드와의 차이점은 제네릭은 런타임 때는 타입 정보가 소거되어버린다**라고 할 수 있다.

```java
// 소스 코드
public GenericExample<T> {
  T field;

  <T> List<T> method() {
    // ...
  } 
}
```

위와 같은 소스 코드들이 런타임 시점에서는...

```java
// 런타임 시점
public GenericExample {
  Object field;

  List method() {
    // ...
  } 
}
```

이렇게 처리되는 것을 **타입 소거**라고 한다. 이런 타입 소거가 제네릭에서 중요한 이유 중 하나가 **제네릭을 쓰지 않는 코드와의 호환성** 때문이다.

원래 제네릭 이전의 자바 코드는 모든 타입이 `Object`의 상속된 자식 타입으로써 존재했는데 이 말은 곧 `Object` 최상위 타입으로는 타입 안정성을 강제할 수 없다는 것이다. 즉, `Object field;`라는 변수를 선언했을 때 해당 변수에 `String` 타입도 담을 수 있고, `Integer` 타입도 담을 수 있는 것이다. 이는 타입 안정성에 위배된다. 이런 타입 안정성 위배를 해결하기 위해 등장한 수단 중 하나가 제네릭이다. 제네릭 같은 경우는 예를 들어 `List<String> list;`라는 변수를 선언하면 해당 리스트 필드에는 무조건 문자열 필드만 들어갈 수 있으므로 **컴파일 시점의 타입 안정성을 강제**할 수 있다.

그런데, 이 타입 강제와 관련하여 중요한 문제가 생기는데 다음 예제 코드를 확인하자. 정적 제네릭 클래스 `Box<T>`를 기반으로 실행 코드를 작성하였다.

```java
public class GenericTest {
    public static void main(String[] args) {
        String test = "Hello";

        // 포장 메소드를 통해 String을 Box<Integer>로 잘못 포장
        Box<Integer> box = boxing(test);  // (1)

        try {
            // Box<Integer>로 잘못된 타입을 얻으려 하므로 CCE 발생
            Integer body = box.getBody(); // (2)
            System.out.println("내용물 = " + body);
        } catch (ClassCastException e) {
            System.err.println("ClassCastException: " + e.getMessage());
        }

        // 매핑 처리
        String mapped = mapping(box, String.class); // (4)
        System.out.println("매핑 처리 = " + mapped);  // "Hello"
    }

    private static <T> Box<T> boxing(String wrongBody) {
        // String을 T로 캐스팅, 제네릭 타입 소거로 T는 Object 타입으로 처리
        return new Box<>((T) wrongBody);  // (3)
    }

    private static <S, T> T mapping(Box<S> box, Class<T> type) {
        // 여기서는 제네릭 타입 S가 무엇이든 간에 내용물 body를 변환
        S body = box.getBody();  // (5)

        // 타입에 맞게 수동으로 변환
        return type.cast(body); // (6)
    }

    public static class Box<T> {
        private final T body;

        public Box(T body) {
            this.body = body;
        }

        public T getBody() {
            return body;
        }
    }
}
```

이 코드를 실행하면 다음과 같은 결과가 확인된다.

```bash
ClassCastException: class java.lang.String cannot be cast to class java.lang.Integer (java.lang.String and java.lang.Integer are in module java.base of loader 'bootstrap')
매핑 처리 = Hello
```

### (2) 타입 소거의 존재 의의

일단 결과물이 잘 출력된 것을 봤을 때, **코드는 정상적으로 실행**됐다. 여기서 가질 수 있는 의문점은 다음과 같다.

> 분명 포장이 잘못(`Integer` 타입 내용물만을 받는 `Box`에 `String` 타입 내용물이 들어감)됐는데, 어떻게 그 단계에서는 문제를 제기하지 않고 꺼낼 때에서야 문제가 제기되는지?

이것의 정답이 바로 **타입 소거**인 것이다. 즉, 컴파일 시점에 타입 소거가 발생하면서 `Box<T>`는 `Box<Object>`처럼 처리(타입 소거)되기 때문에 잘못된 포장은 가능하다. 그러나 이제 이 내용물을 꺼내려고 하니 변수의 타입(`Integer`)과 내용물의 타입(`String`)이 다르기 때문에 CCE를 발생시키는 것이다.

왜 이렇게 복잡한 처리를 했을꼬 하니, 분명 타입 안전성을 강제하기 위해서지만 이 부분은 타입 안정성을 저해하는 것처럼 보인다. 그렇지만 다형성을 실현하기 위해 결국 **유연함의 발휘**가 필요하다. 유연함의 발휘라는 것은 코드 재사용성의 증가아 같다. 만약 타입 소거가 없다면 `Box<String>`과 `Box<Integer>`는 완전 별개의 타입으로 취급돼서 기존의 비 제네릭 코드(`List`)와의 호환성이 떨어지게 된다 처리량이 2배로 늘어날 뿐더러 중복 처리로 인해 메모리 오버헤드가 발생할 수 있다.

예제 코드와 실제 동작 코드를 비교해보면 다음과 같다.

```java
// 런타임 시점
Box box = boxing(test);  // (1)  -> 타입 소거 처리

private static Box boxing(String wrongBody) {
    return new Box<>(wrongBody);  // (2)  -> 이 시점까지 test 변수가 Object 타입으로 들어있다(정상)
}

Integer body = box.getBody();  // (3)  -> Object 타입의 test를 Integer 변수에 담으려고 하니 문제 발생

// ... Box 정적 클래스의 Getter
public static class Box {

    // ...

    public Object getBody() {
        return body;
    }
```

정리하자면 타입 소거 덕분에 (1) 과정에서는 문제가 발생하지 않으나 (2) 과정에서 문제가 발생해서 (3)에서 CCE가 던져지게 되는 것이다.

### (3) 타입 캐스팅 케이스 비교

그럼 이번에는 (4) 이후의 케이스를 보자. 이 경우는 히카리풀 로그를 확인하면 문제없이 잘 처리되고 CCE가 발생하지 않은 걸 볼 수 있다. 분명 (1), (2), (3) 케이스와 같아 보이는데 왜 얘는 문제가 되지 않을까? 이것 역시 타입 소거 덕분이다.

예제 코드와 실제 동작 코드를 비교해보면 다음과 같다.

```java
// 런타임 시점
private static Object mapping(Box box, Class type) {  // -> 타입 소거 처리
    Object body = box.getBody();  // (5)  -> 타입 소거 처리

    return type.cast(body); // (6)  -> 명시적 캐스팅
}



// ... Box 정적 클래스의 Getter
public static class Box {

    // ...

    public Object getBody() {
        return body;
    }
```

요약하자면 런타임 시점 때 `S`나 `T`나 계속 `Object`로 취급되다가 `S`랑 `T`의 타입이 결정될 때 (6)도 똑같은 타입으로 결정되므로 문제없이 동작하게 되는 것이다. 실제 타입은 (6)이 호출되는 런타임 시점 때 결정되므로, 그리고 담는 변수 타입이나 매핑 메소드의 동작 과정에서의 타입이 동시에 결정되므로 캐스팅 오류가 발생하지 않게 된다.



